// tslint:disable
/**
 * MONEI API v1
 * <p>The MONEI API is organized around <a href=\"https://en.wikipedia.org/wiki/Representational_State_Transfer\">REST</a>. Our API has predictable resource-oriented URLs, accepts JSON-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.</p> <h4 id=\"base-url\">Base URL:</h4> <p><a href=\"https://api.monei.com/v1\">https://api.monei.com/v1</a></p> <h4 id=\"client-libraries\">Client libraries:</h4> <ul> <li><a href=\"https://github.com/MONEI/monei-php-sdk\">PHP SDK</a></li> <li><a href=\"https://github.com/MONEI/monei-python-sdk\">Python SDK</a></li> <li><a href=\"https://github.com/MONEI/monei-node-sdk\">Node.js SDK</a></li> <li><a href=\"https://postman.monei.com/\">Postman</a></li> </ul> <h4 id=\"important\">Important:</h4> <p><strong>If you are not using our official SDKs, you need to provide a valid <code>User-Agent</code> header in each request, otherwise your requests will be rejected.</strong></p> 
 *
 * The version of the OpenAPI document: 1.4.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from '../axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivateSubscriptionRequest
 */
export interface ActivateSubscriptionRequest {
    /**
     * A payment token generated by monei.js [Components](https://docs.monei.com/docs/monei-js-overview) or a paymentToken [saved after a previous successful payment](https://docs.monei.com/docs/save-payment-method). In case of the first one, you will also need to send the `sessionId` used to generate the token in the first place. 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    paymentToken?: string;
    /**
     * A unique identifier within your system that adds security to the payment process. You need to pass the same session ID as the one used on the frontend to initialize MONEI Component (if you needed to). This is required if a payment token (not permanent) was already generated in the frontend. 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    sessionId?: string;
    /**
     * The amount to be added to the subscription\'s initial payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof ActivateSubscriptionRequest
     */
    addAmount?: number;
    /**
     * A permanent identifier that refers to the initial payment of a sequence of payments. This value needs to be sent in the path for `RECURRING` payments. 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    sequenceId?: string;
    /**
     * The URL the customer will be directed to after transaction completed (successful or failed - except if `failUrl` is provided). 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    completeUrl?: string;
    /**
     * The URL the customer will be directed to after transaction has failed, instead of `completeUrl` (used in hosted payment page). This allows to provide two different URLs for successful and failed payments. 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    failUrl?: string;
    /**
     * The URL the customer will be directed to if they decide to cancel payment and return to your website (used in hosted payment page). 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    cancelUrl?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof ActivateSubscriptionRequest
     */
    metadata?: object;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof Address
     */
    country?: string;
    /**
     * City, district, suburb, town, or village.
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * Address line 1 (e.g., street, PO Box, or company name).
     * @type {string}
     * @memberof Address
     */
    line1?: string;
    /**
     * Address line 2 (e.g., apartment, suite, unit, or building).
     * @type {string}
     * @memberof Address
     */
    line2?: string;
    /**
     * ZIP or postal code.
     * @type {string}
     * @memberof Address
     */
    zip?: string;
    /**
     * State, county, province, or region.
     * @type {string}
     * @memberof Address
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface CancelPaymentRequest
 */
export interface CancelPaymentRequest {
    /**
     * 
     * @type {PaymentCancellationReason}
     * @memberof CancelPaymentRequest
     */
    cancellationReason?: PaymentCancellationReason;
}
/**
 * 
 * @export
 * @interface CancelSubscriptionRequest
 */
export interface CancelSubscriptionRequest {
    /**
     * If true, the subscription will be canceled at the end of the current period. 
     * @type {boolean}
     * @memberof CancelSubscriptionRequest
     */
    cancelAtPeriodEnd?: boolean;
}
/**
 * 
 * @export
 * @interface CapturePaymentRequest
 */
export interface CapturePaymentRequest {
    /**
     * The amount to capture, which must be less than or equal to the original amount. Any additional amount will be automatically refunded. 
     * @type {number}
     * @memberof CapturePaymentRequest
     */
    amount?: number;
}
/**
 * 
 * @export
 * @interface ConfirmPaymentRequest
 */
export interface ConfirmPaymentRequest {
    /**
     * A payment token generated by monei.js [Components](https://docs.monei.com/docs/monei-js-overview) or a paymentToken [saved after a previous successful payment](https://docs.monei.com/docs/save-payment-method). 
     * @type {string}
     * @memberof ConfirmPaymentRequest
     */
    paymentToken: string;
    /**
     * 
     * @type {ConfirmPaymentRequestPaymentMethod}
     * @memberof ConfirmPaymentRequest
     */
    paymentMethod?: ConfirmPaymentRequestPaymentMethod;
    /**
     * If set to true a permanent token that represents a payment method used in the payment will be generated. 
     * @type {boolean}
     * @memberof ConfirmPaymentRequest
     */
    generatePaymentToken?: boolean;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof ConfirmPaymentRequest
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof ConfirmPaymentRequest
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof ConfirmPaymentRequest
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof ConfirmPaymentRequest
     */
    metadata?: object;
}
/**
 * Additional information about the payment method used for this payment.
 * @export
 * @interface ConfirmPaymentRequestPaymentMethod
 */
export interface ConfirmPaymentRequestPaymentMethod {
    /**
     * 
     * @type {ConfirmPaymentRequestPaymentMethodCard}
     * @memberof ConfirmPaymentRequestPaymentMethod
     */
    card?: ConfirmPaymentRequestPaymentMethodCard;
}
/**
 * Additional information about the card used for this payment.
 * @export
 * @interface ConfirmPaymentRequestPaymentMethodCard
 */
export interface ConfirmPaymentRequestPaymentMethodCard {
    /**
     * The cardholder\'s name, as stated in the credit card.
     * @type {string}
     * @memberof ConfirmPaymentRequestPaymentMethodCard
     */
    cardholderName?: string;
    /**
     * The cardholder\'s email address.
     * @type {string}
     * @memberof ConfirmPaymentRequestPaymentMethodCard
     */
    cardholderEmail?: string;
}
/**
 * 
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof CreatePaymentRequest
     */
    amount: number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    currency: string;
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    orderId: string;
    /**
     * The URL to which a payment result should be sent asynchronously. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    callbackUrl?: string;
    /**
     * The URL the customer will be directed to after transaction completed (successful or failed - except if `failUrl` is provided). 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    completeUrl?: string;
    /**
     * The URL the customer will be directed to after transaction has failed, instead of `completeUrl` (used in hosted payment page). This allows to provide two different URLs for successful and failed payments. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    failUrl?: string;
    /**
     * The URL the customer will be directed to if they decide to cancel payment and return to your website (used in hosted payment page). 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    cancelUrl?: string;
    /**
     * A payment token generated by monei.js [Components](https://docs.monei.com/docs/monei-js-overview) or a paymentToken [saved after a previous successful payment](https://docs.monei.com/docs/save-payment-method). In case of the first one, you will also need to send the `sessionId` used to generate the token in the first place. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    paymentToken?: string;
    /**
     * A unique identifier within your system that adds security to the payment process. You need to pass the same session ID as the one used on the frontend to initialize MONEI Component (if you needed to). This is required if a payment token (not permanent) was already generated in the frontend. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    sessionId?: string;
    /**
     * If set to true a permanent token that represents a payment method used in the payment will be generated. 
     * @type {boolean}
     * @memberof CreatePaymentRequest
     */
    generatePaymentToken?: boolean;
    /**
     * 
     * @type {PaymentPaymentMethodInput}
     * @memberof CreatePaymentRequest
     */
    paymentMethod?: PaymentPaymentMethodInput;
    /**
     * 
     * @type {PaymentPaymentMethods}
     * @memberof CreatePaymentRequest
     */
    allowedPaymentMethods?: PaymentPaymentMethods;
    /**
     * 
     * @type {PaymentTransactionType}
     * @memberof CreatePaymentRequest
     */
    transactionType?: PaymentTransactionType;
    /**
     * 
     * @type {PaymentSequence}
     * @memberof CreatePaymentRequest
     */
    sequence?: PaymentSequence;
    /**
     * A unique identifier of the Point of Sale. If specified the payment is attached to this Point of Sale. If there is a QR code attached to the same Point of Sale, this payment will be available by scanning the QR code. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    pointOfSaleId?: string;
    /**
     * A unique identifier of the Subscription. If specified the payment is attached to this Subscription. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    subscriptionId?: string;
    /**
     * If set to `true`, the new payment will be automatically created when customer visits the payment link of the previously failed payment. Is automatically set to `true` if `completeUrl` is not provided.(set this value to `true` to create \"Pay By Link\" payments).
     * @type {boolean}
     * @memberof CreatePaymentRequest
     */
    autoRecover?: boolean;
    /**
     * An arbitrary string attached to the payment. Often useful for displaying to users. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    description?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof CreatePaymentRequest
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof CreatePaymentRequest
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof CreatePaymentRequest
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * 
     * @type {PaymentSessionDetails}
     * @memberof CreatePaymentRequest
     */
    sessionDetails?: PaymentSessionDetails;
    /**
     * Payment expiration time.
     * @type {number}
     * @memberof CreatePaymentRequest
     */
    expireAt?: number;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof CreatePaymentRequest
     */
    metadata?: object;
}
/**
 * 
 * @export
 * @interface CreateSubscriptionRequest
 */
export interface CreateSubscriptionRequest {
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    amount: number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency. 
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    currency: string;
    /**
     * 
     * @type {SubscriptionInterval}
     * @memberof CreateSubscriptionRequest
     */
    interval: SubscriptionInterval;
    /**
     * Number of intervals between subscription payments.
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    intervalCount?: number;
    /**
     * An arbitrary string attached to the subscription. Often useful for displaying to users. 
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    description?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof CreateSubscriptionRequest
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof CreateSubscriptionRequest
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof CreateSubscriptionRequest
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * The end date of the trial period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    trialPeriodEnd?: number;
    /**
     * Number of days the trial period lasts.
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    trialPeriodDays?: number;
    /**
     * The URL will be called each time subscription status changes. You will receive a subscription object in the body of the request. 
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    callbackUrl?: string;
    /**
     * The URL will be called each time subscription creates a new payments. You will receive the payment object in the body of the request. 
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    paymentCallbackUrl?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof CreateSubscriptionRequest
     */
    metadata?: object;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    success?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    isValid?: boolean;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface PauseSubscriptionRequest
 */
export interface PauseSubscriptionRequest {
    /**
     * If true, the subscription will be paused at the end of the current period. 
     * @type {boolean}
     * @memberof PauseSubscriptionRequest
     */
    pauseAtPeriodEnd?: boolean;
    /**
     * Number of intervals when subscription will be paused before it activates again.
     * @type {number}
     * @memberof PauseSubscriptionRequest
     */
    pauseIntervalCount?: number;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * Unique identifier for the payment.
     * @type {string}
     * @memberof Payment
     */
    id?: string;
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof Payment
     */
    amount?: number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency. 
     * @type {string}
     * @memberof Payment
     */
    currency?: string;
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system. 
     * @type {string}
     * @memberof Payment
     */
    orderId?: string;
    /**
     * An arbitrary string attached to the payment. Often useful for displaying to users. 
     * @type {string}
     * @memberof Payment
     */
    description?: string;
    /**
     * MONEI Account identifier.
     * @type {string}
     * @memberof Payment
     */
    accountId?: string;
    /**
     * Unique identifier provided by the bank performing transaction. 
     * @type {string}
     * @memberof Payment
     */
    authorizationCode?: string;
    /**
     * Has the value `true` if the resource exists in live mode or the value `false` if the resource exists in test mode.
     * @type {boolean}
     * @memberof Payment
     */
    livemode?: boolean;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof Payment
     */
    status?: PaymentStatus;
    /**
     * Payment status code. 
     * @type {string}
     * @memberof Payment
     */
    statusCode?: string;
    /**
     * Human readable status message, can be displayed to a user. 
     * @type {string}
     * @memberof Payment
     */
    statusMessage?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof Payment
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentShop}
     * @memberof Payment
     */
    shop?: PaymentShop;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof Payment
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof Payment
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * Amount in cents refunded (can be less than the amount attribute on the payment if a partial refund was issued). 
     * @type {number}
     * @memberof Payment
     */
    refundedAmount?: number;
    /**
     * Amount in cents refunded in the last transaction.
     * @type {number}
     * @memberof Payment
     */
    lastRefundAmount?: number;
    /**
     * 
     * @type {PaymentLastRefundReason}
     * @memberof Payment
     */
    lastRefundReason?: PaymentLastRefundReason;
    /**
     * 
     * @type {PaymentCancellationReason}
     * @memberof Payment
     */
    cancellationReason?: PaymentCancellationReason;
    /**
     * 
     * @type {PaymentSessionDetails}
     * @memberof Payment
     */
    sessionDetails?: PaymentSessionDetails;
    /**
     * 
     * @type {PaymentTraceDetails}
     * @memberof Payment
     */
    traceDetails?: PaymentTraceDetails;
    /**
     * A permanent token represents a payment method used in the payment. Pass `generatePaymentToken: true` when you creating a payment to generate it. You can pass it as `paymentToken` parameter to create other payments with the same payment method. This token does not expire, and should only be used server-side. 
     * @type {string}
     * @memberof Payment
     */
    paymentToken?: string;
    /**
     * 
     * @type {PaymentPaymentMethod}
     * @memberof Payment
     */
    paymentMethod?: PaymentPaymentMethod;
    /**
     * 
     * @type {PaymentSequence}
     * @memberof Payment
     */
    sequence?: PaymentSequence;
    /**
     * A permanent identifier that refers to the initial payment of a sequence of payments. This value needs to be sent in the path for `RECURRING` payments. 
     * @type {string}
     * @memberof Payment
     */
    sequenceId?: string;
    /**
     * A unique identifier of the Point of Sale. If specified the payment is attached to this Point of Sale. If there is a QR code attached to the same Point of Sale, this payment will be available by scanning the QR code. 
     * @type {string}
     * @memberof Payment
     */
    pointOfSaleId?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof Payment
     */
    metadata?: object;
    /**
     * 
     * @type {PaymentNextAction}
     * @memberof Payment
     */
    nextAction?: PaymentNextAction;
    /**
     * Time at which the resource was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Payment
     */
    createdAt?: number;
    /**
     * Time at which the resource updated last time. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Payment
     */
    updatedAt?: number;
}
/**
 * Billing information associated with the payment method at the time of the transaction. 
 * @export
 * @interface PaymentBillingDetails
 */
export interface PaymentBillingDetails {
    /**
     * The customer’s billing full name.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    name?: string;
    /**
     * The customer’s billing email address.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    email?: string;
    /**
     * The customer’s billing phone number.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    phone?: string;
    /**
     * Billing company name.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    company?: string;
    /**
     * Company tax ID.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    taxId?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentBillingDetails
     */
    address?: Address;
}
/**
 * The reason for canceling the Payment.
 * @export
 * @enum {string}
 */
export enum PaymentCancellationReason {
    duplicated = 'duplicated',
    fraudulent = 'fraudulent',
    requested_by_customer = 'requested_by_customer'
}

/**
 * 
 * @export
 * @interface PaymentCustomer
 */
export interface PaymentCustomer {
    /**
     * The customer’s email address.
     * @type {string}
     * @memberof PaymentCustomer
     */
    email?: string;
    /**
     * The customer’s full name or business name.
     * @type {string}
     * @memberof PaymentCustomer
     */
    name?: string;
    /**
     * The customer’s phone number.
     * @type {string}
     * @memberof PaymentCustomer
     */
    phone?: string;
}
/**
 * The reason of the last refund transaction.
 * @export
 * @enum {string}
 */
export enum PaymentLastRefundReason {
    duplicated = 'duplicated',
    fraudulent = 'fraudulent',
    requested_by_customer = 'requested_by_customer'
}

/**
 * The channel used to send the payment message. 
 * @export
 * @enum {string}
 */
export enum PaymentMessageChannel {
    EMAIL = 'EMAIL',
    WHATSAPP = 'WHATSAPP',
    SMS = 'SMS'
}

/**
 * The language of message sent to the customer. If not provided the default customer language is used if available.
 * @export
 * @enum {string}
 */
export enum PaymentMessageLanguage {
    en = 'en',
    es = 'es',
    ca = 'ca',
    pt = 'pt',
    de = 'de',
    it = 'it',
    fr = 'fr'
}

/**
 * If present, this property tells you what actions you need to take in order for your customer to fulfill a payment using the provided source. 
 * @export
 * @interface PaymentNextAction
 */
export interface PaymentNextAction {
    /**
     * - `CONFIRM` - Your customer needs to be redirected to a   [hosted payment page](https://docs.monei.com/docs/use-prebuilt-payment-page)   or confirm payment using   [payment token](https://docs.monei.com/docs/accept-card-payment#3-submitting-the-payment-to-monei-client-side).   The **redirectUrl** will point to the hosted payment page. - `FRICTIONLESS_CHALLENGE` - Your customer needs to be redirected to the frictionless    3d secure challenge page provided by the bank. The **redirectUrl**    will point to the frictionless 3d secure challenge page provided by the bank. - `CHALLENGE` - Your customer needs to be redirected to the   3d secure challenge page provided by the bank. The **redirectUrl**   will point to the 3d secure challenge page provided by the bank. - `COMPLETE` - The payment is completed. The **redirectUrl** will be   the **completeUrl** if it was provided when the payment was created. - `BIZUM_CHALLENGE` - Your customer will be redirected to the Bizum hosted payment page. 
     * @type {string}
     * @memberof PaymentNextAction
     */
    type?: PaymentNextActionTypeEnum;
    /**
     * If `true` you have to redirect your customer to the **redirectUrl** to continue payment process. 
     * @type {boolean}
     * @memberof PaymentNextAction
     */
    mustRedirect?: boolean;
    /**
     * Redirect your customer to this url to continue payment process. 
     * @type {string}
     * @memberof PaymentNextAction
     */
    redirectUrl?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentNextActionTypeEnum {
    CONFIRM = 'CONFIRM',
    CHALLENGE = 'CHALLENGE',
    FRICTIONLESS_CHALLENGE = 'FRICTIONLESS_CHALLENGE',
    BIZUM_CHALLENGE = 'BIZUM_CHALLENGE',
    COMPLETE = 'COMPLETE'
}

/**
 * Details about the payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethod
 */
export interface PaymentPaymentMethod {
    /**
     * Payment method type.
     * @type {string}
     * @memberof PaymentPaymentMethod
     */
    method?: PaymentPaymentMethodMethodEnum;
    /**
     * 
     * @type {PaymentPaymentMethodCard}
     * @memberof PaymentPaymentMethod
     */
    card?: PaymentPaymentMethodCard;
    /**
     * 
     * @type {PaymentPaymentMethodBizum}
     * @memberof PaymentPaymentMethod
     */
    bizum?: PaymentPaymentMethodBizum;
    /**
     * 
     * @type {PaymentPaymentMethodPaypal}
     * @memberof PaymentPaymentMethod
     */
    paypal?: PaymentPaymentMethodPaypal;
    /**
     * 
     * @type {PaymentPaymentMethodCofidis}
     * @memberof PaymentPaymentMethod
     */
    cofidis?: PaymentPaymentMethodCofidis;
    /**
     * 
     * @type {PaymentPaymentMethodCofidis}
     * @memberof PaymentPaymentMethod
     */
    cofidisLoan?: PaymentPaymentMethodCofidis;
    /**
     * 
     * @type {PaymentPaymentMethodMbway}
     * @memberof PaymentPaymentMethod
     */
    mbway?: PaymentPaymentMethodMbway;
    /**
     * 
     * @type {PaymentPaymentMethodTrustly}
     * @memberof PaymentPaymentMethod
     */
    trustly?: PaymentPaymentMethodTrustly;
    /**
     * 
     * @type {PaymentPaymentMethodSepa}
     * @memberof PaymentPaymentMethod
     */
    sepa?: PaymentPaymentMethodSepa;
    /**
     * 
     * @type {PaymentPaymentMethodKlarna}
     * @memberof PaymentPaymentMethod
     */
    klarna?: PaymentPaymentMethodKlarna;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodMethodEnum {
    card = 'card',
    bizum = 'bizum',
    googlePay = 'googlePay',
    applePay = 'applePay',
    clickToPay = 'clickToPay',
    paypal = 'paypal',
    cofidis = 'cofidis',
    cofidisLoan = 'cofidisLoan',
    iDeal = 'iDeal',
    mbway = 'mbway',
    multibanco = 'multibanco',
    sofort = 'sofort',
    trustly = 'trustly',
    sepa = 'sepa',
    klarna = 'klarna',
    giropay = 'giropay'
}

/**
 * Details about the Bizum account used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodBizum
 */
export interface PaymentPaymentMethodBizum {
    /**
     * The phone number used to pay with `bizum`.
     * @type {string}
     * @memberof PaymentPaymentMethodBizum
     */
    phoneNumber?: string;
}
/**
 * Details about the Bizum account used for this payment. If provided phone number is valid and registered in Bizum, MONEI will try to confirm the payment directly. 
 * @export
 * @interface PaymentPaymentMethodBizumInput
 */
export interface PaymentPaymentMethodBizumInput {
    /**
     * The phone number used to pay with `bizum`.
     * @type {string}
     * @memberof PaymentPaymentMethodBizumInput
     */
    phoneNumber?: string;
}
/**
 * Details about the card used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodCard
 */
export interface PaymentPaymentMethodCard {
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    country?: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    brand?: PaymentPaymentMethodCardBrandEnum;
    /**
     * Card type `debit` or `credit`.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    type?: PaymentPaymentMethodCardTypeEnum;
    /**
     * Whether this transaction used 3D Secure authentication.
     * @type {boolean}
     * @memberof PaymentPaymentMethodCard
     */
    threeDSecure?: boolean;
    /**
     * The protocol version of the 3DS challenge.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    threeDSecureVersion?: string;
    /**
     * The flow used for 3DS authentication. - `CHALLENGE` - In a challenge flow, the issuer requires additional shopper interaction, either through biometrics, two-factor authentication, or similar methods based on [Strong Customer Authentication (SCA)](https://en.wikipedia.org/wiki/Strong_customer_authentication) factors. - `FRICTIONLESS` - In a frictionless flow, the acquirer, issuer, and card scheme exchange all necessary     information in the background through passive authentication using the shopper\'s device     fingerprint. The transaction is completed without further shopper interaction. - `FRICTIONLESS_CHALLENGE` - This flow is the complete 3DS flow. It is similar to the 3DS frictionless flow but     includes an additional authentication step (challenge) that will be invoked if the     information provided in the data collection step does not suffice to determine the     risk-level of the transaction. - `DIRECT` - This transaction did not require [Strong Customer Authentication (SCA)](https://en.wikipedia.org/wiki/Strong_customer_authentication) due to the low risk 
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    threeDSecureFlow?: PaymentPaymentMethodCardThreeDSecureFlowEnum;
    /**
     * Time at which the card will expire. Measured in seconds since the Unix epoch. 
     * @type {number}
     * @memberof PaymentPaymentMethodCard
     */
    expiration?: number;
    /**
     * The last four digits of the card.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    last4?: string;
    /**
     * The digital wallet used to tokenize the card.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    tokenizationMethod?: PaymentPaymentMethodCardTokenizationMethodEnum;
    /**
     * The name of the cardholder.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    cardholderName?: string;
    /**
     * The email of the cardholder.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    cardholderEmail?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodCardBrandEnum {
    visa = 'visa',
    mastercard = 'mastercard',
    diners = 'diners',
    amex = 'amex',
    jcb = 'jcb',
    unionpay = 'unionpay',
    unknown = 'unknown'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodCardTypeEnum {
    debit = 'debit',
    credit = 'credit'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodCardThreeDSecureFlowEnum {
    CHALLENGE = 'CHALLENGE',
    FRICTIONLESS = 'FRICTIONLESS',
    FRICTIONLESS_CHALLENGE = 'FRICTIONLESS_CHALLENGE',
    DIRECT = 'DIRECT'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodCardTokenizationMethodEnum {
    applePay = 'applePay',
    googlePay = 'googlePay',
    clickToPay = 'clickToPay'
}

/**
 * Details about the card used as payment method. If provided, MONEI will try to confirm the payment directly. 
 * @export
 * @interface PaymentPaymentMethodCardInput
 */
export interface PaymentPaymentMethodCardInput {
    /**
     * The card number, as a string without any separators.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    number?: string;
    /**
     * Card security code.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    cvc?: string;
    /**
     * Two-digit number representing the card’s expiration month.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    expMonth?: string;
    /**
     * Two-digit number representing the card’s expiration year.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    expYear?: string;
    /**
     * The cardholder\'s name, as stated in the credit card.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    cardholderName?: string;
    /**
     * The cardholder\'s email address.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    cardholderEmail?: string;
}
/**
 * Details from Cofidis order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodCofidis
 */
export interface PaymentPaymentMethodCofidis {
    /**
     * The Cofidis\' order ID.
     * @type {string}
     * @memberof PaymentPaymentMethodCofidis
     */
    orderId?: string;
}
/**
 * An information about a payment method used for this payment. We recommend using `paymentToken` instead, as it is more secure way to pass sensitive payment information. Processing credit card information on your server requires [PCI DSS compliance](https://www.investopedia.com/terms/p/pci-compliance.asp). 
 * @export
 * @interface PaymentPaymentMethodInput
 */
export interface PaymentPaymentMethodInput {
    /**
     * 
     * @type {PaymentPaymentMethodCardInput}
     * @memberof PaymentPaymentMethodInput
     */
    card?: PaymentPaymentMethodCardInput;
    /**
     * 
     * @type {PaymentPaymentMethodBizumInput}
     * @memberof PaymentPaymentMethodInput
     */
    bizum?: PaymentPaymentMethodBizumInput;
}
/**
 * Details from Klarna order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodKlarna
 */
export interface PaymentPaymentMethodKlarna {
    /**
     * 
     * @type {Enum}
     * @memberof PaymentPaymentMethodKlarna
     */
    billingCategory?: PaymentPaymentMethodKlarnaBillingCategoryEnum;
    /**
     * 
     * @type {Enum}
     * @memberof PaymentPaymentMethodKlarna
     */
    authPaymentMethod?: PaymentPaymentMethodKlarnaAuthPaymentMethodEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodKlarnaBillingCategoryEnum {
    PAY_LATER = 'PAY_LATER',
    PAY_NOW = 'PAY_NOW',
    SLICE_IT = 'SLICE_IT',
    SLICE_IT_BY_CARD = 'SLICE_IT_BY_CARD'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodKlarnaAuthPaymentMethodEnum {
    invoice = 'invoice',
    fixed_amount = 'fixed_amount',
    pix = 'pix',
    base_account = 'base_account',
    deferred_interest = 'deferred_interest',
    direct_debit = 'direct_debit',
    direct_bank_transfer = 'direct_bank_transfer',
    b2b_invoice = 'b2b_invoice',
    card = 'card',
    slice_it_by_card = 'slice_it_by_card'
}

/**
 * Details from MBWay order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodMbway
 */
export interface PaymentPaymentMethodMbway {
    /**
     * The phone number used to pay with `mbway`.
     * @type {string}
     * @memberof PaymentPaymentMethodMbway
     */
    phoneNumber?: string;
}
/**
 * Details from Paypal order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodPaypal
 */
export interface PaymentPaymentMethodPaypal {
    /**
     * The Paypal\'s order ID.
     * @type {string}
     * @memberof PaymentPaymentMethodPaypal
     */
    orderId?: string;
}
/**
 * Details from SEPA order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodSepa
 */
export interface PaymentPaymentMethodSepa {
    /**
     * The address of the account holder.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    accountholderAddress?: string;
    /**
     * The email of the account holder.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    accountholderEmail?: string;
    /**
     * The name of the account holder.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    accountholderName?: string;
    /**
     * The country code of the account holder.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    countryCode?: string;
    /**
     * The address of the bank.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    bankAddress?: string;
    /**
     * The code of the bank.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    bankCode?: string;
    /**
     * The name of the bank.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    bankName?: string;
    /**
     * The BIC of the bank.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    bic?: string;
    /**
     * The last 4 digits of the IBAN.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    last4?: string;
}
/**
 * Details from Trustly order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodTrustly
 */
export interface PaymentPaymentMethodTrustly {
    /**
     * The Trustly\'s customer ID.
     * @type {string}
     * @memberof PaymentPaymentMethodTrustly
     */
    customerId?: string;
}
/**
 * An array of allowed payment methods (used in hosted payment page). Must be enabled payment methods. Possible values:   - `card`   - `bizum`   - `paypal`   - `cofidis`   - `cofidisLoan`   - `multibanco`   - `iDeal`   - `bancontact`   - `sofort`   - `trustly`   - `sepa`   - `klarna`   - `giropay` 
 * @export
 * @interface PaymentPaymentMethods
 */
export interface PaymentPaymentMethods extends Array<string> {
}
/**
 * The reason for refunding the Payment.
 * @export
 * @enum {string}
 */
export enum PaymentRefundReason {
    duplicated = 'duplicated',
    fraudulent = 'fraudulent',
    requested_by_customer = 'requested_by_customer'
}

/**
 * This field needs to be sent in order to mark the beginning of a sequence of payments (recurring/subscriptions, installments, and so). Specific configurations can be set in the inside properties (`recurring`). 
 * @export
 * @interface PaymentSequence
 */
export interface PaymentSequence {
    /**
     * 
     * @type {string}
     * @memberof PaymentSequence
     */
    type: PaymentSequenceTypeEnum;
    /**
     * 
     * @type {PaymentSequenceRecurring}
     * @memberof PaymentSequence
     */
    recurring?: PaymentSequenceRecurring;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentSequenceTypeEnum {
    recurring = 'recurring'
}

/**
 * Specific configurations for recurring payments. Will only be used when `sequence`.`type` is `recurring`. 
 * @export
 * @interface PaymentSequenceRecurring
 */
export interface PaymentSequenceRecurring {
    /**
     * Date after which no further recurring payments will be performed. Must be formatted as `YYYYMMDD`. 
     * @type {string}
     * @memberof PaymentSequenceRecurring
     */
    expiry?: string;
    /**
     * The minimum number of **days** between the different recurring payments. 
     * @type {number}
     * @memberof PaymentSequenceRecurring
     */
    frequency?: number;
}
/**
 * Information related to the browsing session of the user who initiated the payment. 
 * @export
 * @interface PaymentSessionDetails
 */
export interface PaymentSessionDetails {
    /**
     * The IP address where the operation originated.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    ip?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    countryCode?: string;
    /**
     * Two-letter language code ([ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1)).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    lang?: string;
    /**
     * Device type, could be `desktop`, `mobile`, `smartTV`, `tablet`.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    deviceType?: string;
    /**
     * Information about the device used for the browser session (e.g., `iPhone`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    deviceModel?: string;
    /**
     * The browser used in this browser session (e.g., `Mobile Safari`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    browser?: string;
    /**
     * The version for the browser session (e.g., `13.1.1`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    browserVersion?: string;
    /**
     * Operation system (e.g., `iOS`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    os?: string;
    /**
     * Operation system version (e.g., `13.5.1`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    osVersion?: string;
    /**
     * The source component from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    source?: string;
    /**
     * The source component version from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    sourceVersion?: string;
    /**
     * Full user agent string of the browser session.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    userAgent?: string;
    /**
     * Browser accept header.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    browserAccept?: string;
    /**
     * The color depth of the browser session (e.g., `24`).
     * @type {number}
     * @memberof PaymentSessionDetails
     */
    browserColorDepth?: number;
    /**
     * The screen height of the browser session (e.g., `1152`).
     * @type {number}
     * @memberof PaymentSessionDetails
     */
    browserScreenHeight?: number;
    /**
     * The screen width of the browser session (e.g., `2048`).
     * @type {number}
     * @memberof PaymentSessionDetails
     */
    browserScreenWidth?: number;
    /**
     * The timezone offset of the browser session (e.g., `-120`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    browserTimezoneOffset?: string;
}
/**
 * Shipping information associated with the payment.
 * @export
 * @interface PaymentShippingDetails
 */
export interface PaymentShippingDetails {
    /**
     * The shipping customer’s full name.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    name?: string;
    /**
     * The shipping customer’s email address.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    email?: string;
    /**
     * The shipping customer’s phone number.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    phone?: string;
    /**
     * Name of the company where the shipment is going.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    company?: string;
    /**
     * Company tax ID.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    taxId?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentShippingDetails
     */
    address?: Address;
}
/**
 * The information about the shop (used in [hosted payment page](https://docs.monei.com/docs/use-prebuilt-payment-page)). 
 * @export
 * @interface PaymentShop
 */
export interface PaymentShop {
    /**
     * The shop name.
     * @type {string}
     * @memberof PaymentShop
     */
    name?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentShop
     */
    country?: string;
}
/**
 * The status of the payment.
 * @export
 * @enum {string}
 */
export enum PaymentStatus {
    SUCCEEDED = 'SUCCEEDED',
    PENDING = 'PENDING',
    FAILED = 'FAILED',
    CANCELED = 'CANCELED',
    REFUNDED = 'REFUNDED',
    PARTIALLY_REFUNDED = 'PARTIALLY_REFUNDED',
    AUTHORIZED = 'AUTHORIZED',
    EXPIRED = 'EXPIRED'
}

/**
 * Information related to the browsing session of the user who initiated the payment. 
 * @export
 * @interface PaymentTraceDetails
 */
export interface PaymentTraceDetails {
    /**
     * The IP address where the operation originated.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    ip?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    countryCode?: string;
    /**
     * Two-letter language code ([ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1)).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    lang?: string;
    /**
     * Device type, could be `desktop`, `mobile`, `smartTV`, `tablet`.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    deviceType?: string;
    /**
     * Information about the device used for the browser session (e.g., `iPhone`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    deviceModel?: string;
    /**
     * The browser used in this browser session (e.g., `Mobile Safari`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    browser?: string;
    /**
     * The version for the browser session (e.g., `13.1.1`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    browserVersion?: string;
    /**
     * Operation system (e.g., `iOS`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    os?: string;
    /**
     * Operation system version (e.g., `13.5.1`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    osVersion?: string;
    /**
     * The source component from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    source?: string;
    /**
     * The source component version from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    sourceVersion?: string;
    /**
     * Full user agent string of the browser session.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    userAgent?: string;
    /**
     * Browser accept header.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    browserAccept?: string;
    /**
     * The color depth of the browser session (e.g., `24`).
     * @type {number}
     * @memberof PaymentTraceDetails
     */
    browserColorDepth?: number;
    /**
     * The screen height of the browser session (e.g., `1152`).
     * @type {number}
     * @memberof PaymentTraceDetails
     */
    browserScreenHeight?: number;
    /**
     * The screen width of the browser session (e.g., `2048`).
     * @type {number}
     * @memberof PaymentTraceDetails
     */
    browserScreenWidth?: number;
    /**
     * The timezone offset of the browser session (e.g., `-120`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    browserTimezoneOffset?: string;
    /**
     * The ID of the user that started the operation.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    userId?: string;
    /**
     * The email of the user that started the operation.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    userEmail?: string;
}
/**
 * Controls when the funds will be captured.   - `SALE` - **Default**. MONEI automatically captures funds     when the customer authorizes the payment.   - `AUTH` - Place a hold on the funds when the customer authorizes     the payment, but don’t capture the funds until later.   - `PAYOUT` - Send funds to the customer   - `VERIF` - Verify the card without placing a hold or capturing funds. 
 * @export
 * @enum {string}
 */
export enum PaymentTransactionType {
    SALE = 'SALE',
    AUTH = 'AUTH',
    PAYOUT = 'PAYOUT',
    VERIF = 'VERIF'
}

/**
 * 
 * @export
 * @interface RecurringPaymentRequest
 */
export interface RecurringPaymentRequest {
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system. 
     * @type {string}
     * @memberof RecurringPaymentRequest
     */
    orderId: string;
    /**
     * The amount to collected by this subsequent payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof RecurringPaymentRequest
     */
    amount?: number;
    /**
     * Same as the `transactionType` parameter from [create payment](https://docs.monei.com/api/#operation/payments_create). If not sent, it will default in the same transaction type used in the initial payment. 
     * @type {PaymentTransactionType}
     * @memberof RecurringPaymentRequest
     */
    transactionType?: PaymentTransactionType;
    /**
     * An arbitrary string attached to the payment. Often useful for displaying to users. 
     * @type {string}
     * @memberof RecurringPaymentRequest
     */
    description?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof RecurringPaymentRequest
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof RecurringPaymentRequest
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof RecurringPaymentRequest
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * The URL to which a payment result should be sent asynchronously. 
     * @type {string}
     * @memberof RecurringPaymentRequest
     */
    callbackUrl?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof RecurringPaymentRequest
     */
    metadata?: object;
}
/**
 * 
 * @export
 * @interface RefundPaymentRequest
 */
export interface RefundPaymentRequest {
    /**
     * The amount to refund, which must be less than or equal to the original amount. 
     * @type {number}
     * @memberof RefundPaymentRequest
     */
    amount?: number;
    /**
     * 
     * @type {PaymentRefundReason}
     * @memberof RefundPaymentRequest
     */
    refundReason?: PaymentRefundReason;
}
/**
 * 
 * @export
 * @interface RegisterDomainRequest
 */
export interface RegisterDomainRequest {
    /**
     * The domain name to register for Apple Pay.
     * @type {string}
     * @memberof RegisterDomainRequest
     */
    domainName: string;
}
/**
 * 
 * @export
 * @interface SendPaymentLinkRequest
 */
export interface SendPaymentLinkRequest {
    /**
     * The customer will receive payment link on this email address.
     * @type {string}
     * @memberof SendPaymentLinkRequest
     */
    customerEmail?: string;
    /**
     * Phone number in E.164 format. The customer will receive payment link on this phone number.
     * @type {string}
     * @memberof SendPaymentLinkRequest
     */
    customerPhone?: string;
    /**
     * 
     * @type {PaymentMessageChannel}
     * @memberof SendPaymentLinkRequest
     */
    channel?: PaymentMessageChannel;
    /**
     * 
     * @type {PaymentMessageLanguage}
     * @memberof SendPaymentLinkRequest
     */
    language?: PaymentMessageLanguage;
}
/**
 * 
 * @export
 * @interface SendPaymentReceiptRequest
 */
export interface SendPaymentReceiptRequest {
    /**
     * The customer will receive payment receipt on this email address.
     * @type {string}
     * @memberof SendPaymentReceiptRequest
     */
    customerEmail?: string;
    /**
     * Phone number in E.164 format. The customer will receive payment receipt link on this phone number.
     * @type {string}
     * @memberof SendPaymentReceiptRequest
     */
    customerPhone?: string;
    /**
     * 
     * @type {PaymentMessageChannel}
     * @memberof SendPaymentReceiptRequest
     */
    channel?: PaymentMessageChannel;
    /**
     * 
     * @type {PaymentMessageLanguage}
     * @memberof SendPaymentReceiptRequest
     */
    language?: PaymentMessageLanguage;
}
/**
 * 
 * @export
 * @interface SendPaymentRequest
 */
export interface SendPaymentRequest {
    /**
     * Phone number in E.164 format. The customer will receive payment link on this phone number.
     * @type {string}
     * @memberof SendPaymentRequest
     */
    phoneNumber: string;
    /**
     * 
     * @type {PaymentMessageLanguage}
     * @memberof SendPaymentRequest
     */
    language?: PaymentMessageLanguage;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * Unique identifier for the subscription.
     * @type {string}
     * @memberof Subscription
     */
    id?: string;
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof Subscription
     */
    amount?: number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency. 
     * @type {string}
     * @memberof Subscription
     */
    currency?: string;
    /**
     * An arbitrary string attached to the subscription. Often useful for displaying to users. 
     * @type {string}
     * @memberof Subscription
     */
    description?: string;
    /**
     * MONEI Account identifier.
     * @type {string}
     * @memberof Subscription
     */
    accountId?: string;
    /**
     * Has the value `true` if the resource exists in live mode or the value `false` if the resource exists in test mode.
     * @type {boolean}
     * @memberof Subscription
     */
    livemode?: boolean;
    /**
     * 
     * @type {SubscriptionStatus}
     * @memberof Subscription
     */
    status?: SubscriptionStatus;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof Subscription
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof Subscription
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof Subscription
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * 
     * @type {SubscriptionInterval}
     * @memberof Subscription
     */
    interval?: SubscriptionInterval;
    /**
     * Number of intervals between subscription payments.
     * @type {number}
     * @memberof Subscription
     */
    intervalCount?: number;
    /**
     * Number of intervals when subscription will be paused before it activates again.
     * @type {number}
     * @memberof Subscription
     */
    pauseIntervalCount?: number;
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system. 
     * @type {string}
     * @memberof Subscription
     */
    lastOrderId?: string;
    /**
     * 
     * @type {SubscriptionLastPayment}
     * @memberof Subscription
     */
    lastPayment?: SubscriptionLastPayment;
    /**
     * 
     * @type {SubscriptionPaymentMethod}
     * @memberof Subscription
     */
    paymentMethod?: SubscriptionPaymentMethod;
    /**
     * The start date of the current subscription period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    currentPeriodStart?: number;
    /**
     * The end date of the current subscription period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    currentPeriodEnd?: number;
    /**
     * The end date of the trial period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    trialPeriodEnd?: number;
    /**
     * The date when the next payment will be made.
     * @type {number}
     * @memberof Subscription
     */
    nextPaymentAt?: number;
    /**
     * Number of retries left for the subscription.
     * @type {number}
     * @memberof Subscription
     */
    retryCount?: number;
    /**
     * If true, the subscription will be canceled at the end of the current period. 
     * @type {boolean}
     * @memberof Subscription
     */
    cancelAtPeriodEnd?: boolean;
    /**
     * If true, the subscription will be paused at the end of the current period. 
     * @type {boolean}
     * @memberof Subscription
     */
    pauseAtPeriodEnd?: boolean;
    /**
     * 
     * @type {PaymentTraceDetails}
     * @memberof Subscription
     */
    traceDetails?: PaymentTraceDetails;
    /**
     * A permanent identifier that refers to the initial payment of a sequence of payments. This value needs to be sent in the path for `RECURRING` payments. 
     * @type {string}
     * @memberof Subscription
     */
    sequenceId?: string;
    /**
     * The URL will be called each time subscription status changes. You will receive a subscription object in the body of the request. 
     * @type {string}
     * @memberof Subscription
     */
    callbackUrl?: string;
    /**
     * The URL will be called each time subscription creates a new payments. You will receive the payment object in the body of the request. 
     * @type {string}
     * @memberof Subscription
     */
    paymentCallbackUrl?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof Subscription
     */
    metadata?: object;
    /**
     * Time at which the resource was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    createdAt?: number;
    /**
     * Time at which the resource updated last time. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    updatedAt?: number;
}
/**
 * Subscription interval.
 * @export
 * @enum {string}
 */
export enum SubscriptionInterval {
    day = 'day',
    week = 'week',
    month = 'month',
    year = 'year'
}

/**
 * 
 * @export
 * @interface SubscriptionLastPayment
 */
export interface SubscriptionLastPayment {
    /**
     * Unique identifier for the payment.
     * @type {string}
     * @memberof SubscriptionLastPayment
     */
    id?: string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof SubscriptionLastPayment
     */
    status?: PaymentStatus;
    /**
     * Payment status code. 
     * @type {string}
     * @memberof SubscriptionLastPayment
     */
    statusCode?: string;
    /**
     * Human readable status message, can be displayed to a user. 
     * @type {string}
     * @memberof SubscriptionLastPayment
     */
    statusMessage?: string;
}
/**
 * Details about the payment method at the time of the transaction. 
 * @export
 * @interface SubscriptionPaymentMethod
 */
export interface SubscriptionPaymentMethod {
    /**
     * Subscription method type.
     * @type {string}
     * @memberof SubscriptionPaymentMethod
     */
    method?: SubscriptionPaymentMethodMethodEnum;
    /**
     * 
     * @type {PaymentPaymentMethodCard}
     * @memberof SubscriptionPaymentMethod
     */
    card?: PaymentPaymentMethodCard;
}

/**
    * @export
    * @enum {string}
    */
export enum SubscriptionPaymentMethodMethodEnum {
    card = 'card'
}

/**
 * Details about the card used as payment method at the time of the transaction. 
 * @export
 * @interface SubscriptionPaymentMethodCard
 */
export interface SubscriptionPaymentMethodCard {
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    country?: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    brand?: SubscriptionPaymentMethodCardBrandEnum;
    /**
     * Card type `debit` or `credit`.
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    type?: SubscriptionPaymentMethodCardTypeEnum;
    /**
     * Wether this transaction used 3D Secure authentication.
     * @type {boolean}
     * @memberof SubscriptionPaymentMethodCard
     */
    threeDSecure?: boolean;
    /**
     * The protocol version of the 3DS challenge.
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    threeDSecureVersion?: string;
    /**
     * Time at which the card will expire. Measured in seconds since the Unix epoch. 
     * @type {number}
     * @memberof SubscriptionPaymentMethodCard
     */
    expiration?: number;
    /**
     * The last four digits of the card.
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    last4?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SubscriptionPaymentMethodCardBrandEnum {
    visa = 'visa',
    mastercard = 'mastercard',
    diners = 'diners',
    amex = 'amex',
    jcb = 'jcb',
    unionpay = 'unionpay',
    unknown = 'unknown'
}
/**
    * @export
    * @enum {string}
    */
export enum SubscriptionPaymentMethodCardTypeEnum {
    debit = 'debit',
    credit = 'credit'
}

/**
 * The status of the subscription.
 * @export
 * @enum {string}
 */
export enum SubscriptionStatus {
    PENDING = 'PENDING',
    EXPIRED = 'EXPIRED',
    TRIALING = 'TRIALING',
    ACTIVE = 'ACTIVE',
    PAST_DUE = 'PAST_DUE',
    PAUSED = 'PAUSED',
    CANCELED = 'CANCELED'
}

/**
 * 
 * @export
 * @interface UpdateSubscriptionRequest
 */
export interface UpdateSubscriptionRequest {
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof UpdateSubscriptionRequest
     */
    amount?: number;
    /**
     * 
     * @type {SubscriptionInterval}
     * @memberof UpdateSubscriptionRequest
     */
    interval?: SubscriptionInterval;
    /**
     * Number of intervals between subscription payments.
     * @type {number}
     * @memberof UpdateSubscriptionRequest
     */
    intervalCount?: number;
    /**
     * An arbitrary string attached to the subscription. Often useful for displaying to users. 
     * @type {string}
     * @memberof UpdateSubscriptionRequest
     */
    description?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof UpdateSubscriptionRequest
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof UpdateSubscriptionRequest
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof UpdateSubscriptionRequest
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * The end date of the trial period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof UpdateSubscriptionRequest
     */
    trialPeriodEnd?: number;
    /**
     * The URL will be called each time subscription status changes. You will receive a subscription object in the body of the request. 
     * @type {string}
     * @memberof UpdateSubscriptionRequest
     */
    callbackUrl?: string;
    /**
     * The URL will be called each time subscription creates a new payments. You will receive the payment object in the body of the request. 
     * @type {string}
     * @memberof UpdateSubscriptionRequest
     */
    paymentCallbackUrl?: string;
    /**
     * If true, the subscription will be paused at the end of the current period. 
     * @type {boolean}
     * @memberof UpdateSubscriptionRequest
     */
    pauseAtPeriodEnd?: boolean;
    /**
     * If true, the subscription will be canceled at the end of the current period. 
     * @type {boolean}
     * @memberof UpdateSubscriptionRequest
     */
    cancelAtPeriodEnd?: boolean;
    /**
     * Number of intervals when subscription will be paused before it activates again.
     * @type {number}
     * @memberof UpdateSubscriptionRequest
     */
    pauseIntervalCount?: number;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof UpdateSubscriptionRequest
     */
    metadata?: object;
}
/**
 * 
 * @export
 * @interface ValidateBizumPhoneRequest
 */
export interface ValidateBizumPhoneRequest {
    /**
     * MONEI Account identifier.
     * @type {string}
     * @memberof ValidateBizumPhoneRequest
     */
    accountId: string;
    /**
     * Unique identifier for the payment.
     * @type {string}
     * @memberof ValidateBizumPhoneRequest
     */
    paymentId?: string;
    /**
     * Phone number in E.164 format.
     * @type {string}
     * @memberof ValidateBizumPhoneRequest
     */
    phoneNumber: string;
}

/**
 * ApplePayDomainApi - axios parameter creator
 * @export
 */
export const ApplePayDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Registers custom domain for Apple Pay.</p> <p>Download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you’re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p> 
         * @summary Register
         * @param {RegisterDomainRequest} registerDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerDomainRequest: RegisterDomainRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDomainRequest' is not null or undefined
            if (registerDomainRequest === null || registerDomainRequest === undefined) {
                throw new RequiredError('registerDomainRequest','Required parameter registerDomainRequest was null or undefined when calling register.');
            }
            const localVarPath = `/apple-pay/domains`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof registerDomainRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(registerDomainRequest !== undefined ? registerDomainRequest : {}) : (registerDomainRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplePayDomainApi - functional programming interface
 * @export
 */
export const ApplePayDomainApiFp = function(configuration?: Configuration) {
    return {
        /**
         * <p>Registers custom domain for Apple Pay.</p> <p>Download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you’re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p> 
         * @summary Register
         * @param {RegisterDomainRequest} registerDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerDomainRequest: RegisterDomainRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await ApplePayDomainApiAxiosParamCreator(configuration).register(registerDomainRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApplePayDomainApi - factory interface
 * @export
 */
export const ApplePayDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * <p>Registers custom domain for Apple Pay.</p> <p>Download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you’re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p> 
         * @summary Register
         * @param {RegisterDomainRequest} registerDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerDomainRequest: RegisterDomainRequest, options?: any): AxiosPromise<InlineResponse200> {
            return ApplePayDomainApiFp(configuration).register(registerDomainRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplePayDomainApi - object-oriented interface
 * @export
 * @class ApplePayDomainApi
 * @extends {BaseAPI}
 */
export class ApplePayDomainApi extends BaseAPI {
    /**
     * <p>Registers custom domain for Apple Pay.</p> <p>Download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you’re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p> 
     * @summary Register
     * @param {RegisterDomainRequest} registerDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplePayDomainApi
     */
    public register(registerDomainRequest: RegisterDomainRequest, options?: any) {
        return ApplePayDomainApiFp(this.configuration).register(registerDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BizumApi - axios parameter creator
 * @export
 */
export const BizumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Verifies if the provided phone number is registered in Bizum. This method does not require authentication. Either <code>accountId</code> or <code>paymentId</code> must be provided in the request body.</p> 
         * @summary Validate Phone
         * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhone: async (validateBizumPhoneRequest: ValidateBizumPhoneRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateBizumPhoneRequest' is not null or undefined
            if (validateBizumPhoneRequest === null || validateBizumPhoneRequest === undefined) {
                throw new RequiredError('validateBizumPhoneRequest','Required parameter validateBizumPhoneRequest was null or undefined when calling validatePhone.');
            }
            const localVarPath = `/bizum/validate-phone`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validateBizumPhoneRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validateBizumPhoneRequest !== undefined ? validateBizumPhoneRequest : {}) : (validateBizumPhoneRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BizumApi - functional programming interface
 * @export
 */
export const BizumApiFp = function(configuration?: Configuration) {
    return {
        /**
         * <p>Verifies if the provided phone number is registered in Bizum. This method does not require authentication. Either <code>accountId</code> or <code>paymentId</code> must be provided in the request body.</p> 
         * @summary Validate Phone
         * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePhone(validateBizumPhoneRequest: ValidateBizumPhoneRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await BizumApiAxiosParamCreator(configuration).validatePhone(validateBizumPhoneRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BizumApi - factory interface
 * @export
 */
export const BizumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * <p>Verifies if the provided phone number is registered in Bizum. This method does not require authentication. Either <code>accountId</code> or <code>paymentId</code> must be provided in the request body.</p> 
         * @summary Validate Phone
         * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhone(validateBizumPhoneRequest: ValidateBizumPhoneRequest, options?: any): AxiosPromise<InlineResponse2001> {
            return BizumApiFp(configuration).validatePhone(validateBizumPhoneRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BizumApi - object-oriented interface
 * @export
 * @class BizumApi
 * @extends {BaseAPI}
 */
export class BizumApi extends BaseAPI {
    /**
     * <p>Verifies if the provided phone number is registered in Bizum. This method does not require authentication. Either <code>accountId</code> or <code>paymentId</code> must be provided in the request body.</p> 
     * @summary Validate Phone
     * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BizumApi
     */
    public validatePhone(validateBizumPhoneRequest: ValidateBizumPhoneRequest, options?: any) {
        return BizumApiFp(this.configuration).validatePhone(validateBizumPhoneRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status.  This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`. 
         * @summary Cancel Payment
         * @param {string} id The payment ID
         * @param {CancelPaymentRequest} [cancelPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, cancelPaymentRequest?: CancelPaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cancel.');
            }
            const localVarPath = `/payments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof cancelPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cancelPaymentRequest !== undefined ? cancelPaymentRequest : {}) : (cancelPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.  Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable. 
         * @summary Capture Payment
         * @param {string} id The payment ID
         * @param {CapturePaymentRequest} [capturePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capture: async (id: string, capturePaymentRequest?: CapturePaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling capture.');
            }
            const localVarPath = `/payments/{id}/capture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof capturePaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(capturePaymentRequest !== undefined ? capturePaymentRequest : {}) : (capturePaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status.  You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview).  You can provide additional customer information, it will override the information passed in **create payment** request. 
         * @summary Confirm Payment
         * @param {string} id The payment ID
         * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm: async (id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling confirm.');
            }
            const localVarPath = `/payments/{id}/confirm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof confirmPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(confirmPaymentRequest !== undefined ? confirmPaymentRequest : {}) : (confirmPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To charge a credit card or other payment method, you create a Payment.  Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page. 
         * @summary Create Payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createPaymentRequest: CreatePaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentRequest' is not null or undefined
            if (createPaymentRequest === null || createPaymentRequest === undefined) {
                throw new RequiredError('createPaymentRequest','Required parameter createPaymentRequest was null or undefined when calling create.');
            }
            const localVarPath = `/payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createPaymentRequest !== undefined ? createPaymentRequest : {}) : (createPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request. 
         * @summary Get Payment
         * @param {string} id The payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment.  If amount is not specified, it will default to the same amount from the original payment. 
         * @summary Recurring Payment
         * @param {string} sequenceId The sequence ID
         * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurring: async (sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            if (sequenceId === null || sequenceId === undefined) {
                throw new RequiredError('sequenceId','Required parameter sequenceId was null or undefined when calling recurring.');
            }
            const localVarPath = `/payments/{sequenceId}/recurring`
                .replace(`{${"sequenceId"}}`, encodeURIComponent(String(sequenceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof recurringPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(recurringPaymentRequest !== undefined ? recurringPaymentRequest : {}) : (recurringPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.  You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded.  Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment. 
         * @summary Refund Payment
         * @param {string} id The payment ID
         * @param {RefundPaymentRequest} [refundPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refund: async (id: string, refundPaymentRequest?: RefundPaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling refund.');
            }
            const localVarPath = `/payments/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof refundPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(refundPaymentRequest !== undefined ? refundPaymentRequest : {}) : (refundPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a payment link to the customer. If payment has customer email, the link is sent via email. If payment has customer phone, the link is sent via WhatsApp, if the phone number is not registered in WhatsApp, the link is sent via SMS. 
         * @summary Send Payment Link
         * @param {string} id The payment ID
         * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLink: async (id: string, sendPaymentLinkRequest?: SendPaymentLinkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendLink.');
            }
            const localVarPath = `/payments/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof sendPaymentLinkRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sendPaymentLinkRequest !== undefined ? sendPaymentLinkRequest : {}) : (sendPaymentLinkRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a payment receipt to the customer. If payment has customer email, the receipt is sent via email. If payment has customer phone, the receipt is sent via WhatsApp, if the phone number is not registered in WhatsApp, the receipt is sent via SMS. 
         * @summary Send Payment Receipt
         * @param {string} id The payment ID
         * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReceipt: async (id: string, sendPaymentReceiptRequest?: SendPaymentReceiptRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendReceipt.');
            }
            const localVarPath = `/payments/{id}/receipt`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof sendPaymentReceiptRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sendPaymentReceiptRequest !== undefined ? sendPaymentReceiptRequest : {}) : (sendPaymentReceiptRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a payment request directly to the customer\'s phone. If Bizum payment method is available and the phone number is registered in Bizum, the customer will get a push notification to confirm the payment directly in the banking app, otherwise, he will receive a link to pay via WhatsApp. 
         * @summary Send Payment Request
         * @param {string} id The payment ID
         * @param {SendPaymentRequest} sendPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRequest: async (id: string, sendPaymentRequest: SendPaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendRequest.');
            }
            // verify required parameter 'sendPaymentRequest' is not null or undefined
            if (sendPaymentRequest === null || sendPaymentRequest === undefined) {
                throw new RequiredError('sendPaymentRequest','Required parameter sendPaymentRequest was null or undefined when calling sendRequest.');
            }
            const localVarPath = `/payments/{id}/rtp`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof sendPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sendPaymentRequest !== undefined ? sendPaymentRequest : {}) : (sendPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status.  This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`. 
         * @summary Cancel Payment
         * @param {string} id The payment ID
         * @param {CancelPaymentRequest} [cancelPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, cancelPaymentRequest?: CancelPaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).cancel(id, cancelPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.  Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable. 
         * @summary Capture Payment
         * @param {string} id The payment ID
         * @param {CapturePaymentRequest} [capturePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capture(id: string, capturePaymentRequest?: CapturePaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).capture(id, capturePaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status.  You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview).  You can provide additional customer information, it will override the information passed in **create payment** request. 
         * @summary Confirm Payment
         * @param {string} id The payment ID
         * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirm(id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).confirm(id, confirmPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * To charge a credit card or other payment method, you create a Payment.  Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page. 
         * @summary Create Payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createPaymentRequest: CreatePaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).create(createPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request. 
         * @summary Get Payment
         * @param {string} id The payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).get(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment.  If amount is not specified, it will default to the same amount from the original payment. 
         * @summary Recurring Payment
         * @param {string} sequenceId The sequence ID
         * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recurring(sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).recurring(sequenceId, recurringPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.  You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded.  Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment. 
         * @summary Refund Payment
         * @param {string} id The payment ID
         * @param {RefundPaymentRequest} [refundPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refund(id: string, refundPaymentRequest?: RefundPaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).refund(id, refundPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sends a payment link to the customer. If payment has customer email, the link is sent via email. If payment has customer phone, the link is sent via WhatsApp, if the phone number is not registered in WhatsApp, the link is sent via SMS. 
         * @summary Send Payment Link
         * @param {string} id The payment ID
         * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLink(id: string, sendPaymentLinkRequest?: SendPaymentLinkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).sendLink(id, sendPaymentLinkRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sends a payment receipt to the customer. If payment has customer email, the receipt is sent via email. If payment has customer phone, the receipt is sent via WhatsApp, if the phone number is not registered in WhatsApp, the receipt is sent via SMS. 
         * @summary Send Payment Receipt
         * @param {string} id The payment ID
         * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendReceipt(id: string, sendPaymentReceiptRequest?: SendPaymentReceiptRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).sendReceipt(id, sendPaymentReceiptRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sends a payment request directly to the customer\'s phone. If Bizum payment method is available and the phone number is registered in Bizum, the customer will get a push notification to confirm the payment directly in the banking app, otherwise, he will receive a link to pay via WhatsApp. 
         * @summary Send Payment Request
         * @param {string} id The payment ID
         * @param {SendPaymentRequest} sendPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRequest(id: string, sendPaymentRequest: SendPaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).sendRequest(id, sendPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status.  This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`. 
         * @summary Cancel Payment
         * @param {string} id The payment ID
         * @param {CancelPaymentRequest} [cancelPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, cancelPaymentRequest?: CancelPaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).cancel(id, cancelPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.  Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable. 
         * @summary Capture Payment
         * @param {string} id The payment ID
         * @param {CapturePaymentRequest} [capturePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capture(id: string, capturePaymentRequest?: CapturePaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).capture(id, capturePaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status.  You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview).  You can provide additional customer information, it will override the information passed in **create payment** request. 
         * @summary Confirm Payment
         * @param {string} id The payment ID
         * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm(id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).confirm(id, confirmPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To charge a credit card or other payment method, you create a Payment.  Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page. 
         * @summary Create Payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createPaymentRequest: CreatePaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).create(createPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request. 
         * @summary Get Payment
         * @param {string} id The payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).get(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment.  If amount is not specified, it will default to the same amount from the original payment. 
         * @summary Recurring Payment
         * @param {string} sequenceId The sequence ID
         * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurring(sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).recurring(sequenceId, recurringPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.  You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded.  Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment. 
         * @summary Refund Payment
         * @param {string} id The payment ID
         * @param {RefundPaymentRequest} [refundPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refund(id: string, refundPaymentRequest?: RefundPaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).refund(id, refundPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a payment link to the customer. If payment has customer email, the link is sent via email. If payment has customer phone, the link is sent via WhatsApp, if the phone number is not registered in WhatsApp, the link is sent via SMS. 
         * @summary Send Payment Link
         * @param {string} id The payment ID
         * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLink(id: string, sendPaymentLinkRequest?: SendPaymentLinkRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).sendLink(id, sendPaymentLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a payment receipt to the customer. If payment has customer email, the receipt is sent via email. If payment has customer phone, the receipt is sent via WhatsApp, if the phone number is not registered in WhatsApp, the receipt is sent via SMS. 
         * @summary Send Payment Receipt
         * @param {string} id The payment ID
         * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReceipt(id: string, sendPaymentReceiptRequest?: SendPaymentReceiptRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).sendReceipt(id, sendPaymentReceiptRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a payment request directly to the customer\'s phone. If Bizum payment method is available and the phone number is registered in Bizum, the customer will get a push notification to confirm the payment directly in the banking app, otherwise, he will receive a link to pay via WhatsApp. 
         * @summary Send Payment Request
         * @param {string} id The payment ID
         * @param {SendPaymentRequest} sendPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRequest(id: string, sendPaymentRequest: SendPaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).sendRequest(id, sendPaymentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status.  This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`. 
     * @summary Cancel Payment
     * @param {string} id The payment ID
     * @param {CancelPaymentRequest} [cancelPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public cancel(id: string, cancelPaymentRequest?: CancelPaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).cancel(id, cancelPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.  Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable. 
     * @summary Capture Payment
     * @param {string} id The payment ID
     * @param {CapturePaymentRequest} [capturePaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public capture(id: string, capturePaymentRequest?: CapturePaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).capture(id, capturePaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status.  You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview).  You can provide additional customer information, it will override the information passed in **create payment** request. 
     * @summary Confirm Payment
     * @param {string} id The payment ID
     * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public confirm(id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).confirm(id, confirmPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To charge a credit card or other payment method, you create a Payment.  Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page. 
     * @summary Create Payment
     * @param {CreatePaymentRequest} createPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public create(createPaymentRequest: CreatePaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).create(createPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request. 
     * @summary Get Payment
     * @param {string} id The payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public get(id: string, options?: any) {
        return PaymentsApiFp(this.configuration).get(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment.  If amount is not specified, it will default to the same amount from the original payment. 
     * @summary Recurring Payment
     * @param {string} sequenceId The sequence ID
     * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public recurring(sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).recurring(sequenceId, recurringPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.  You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded.  Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment. 
     * @summary Refund Payment
     * @param {string} id The payment ID
     * @param {RefundPaymentRequest} [refundPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public refund(id: string, refundPaymentRequest?: RefundPaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).refund(id, refundPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a payment link to the customer. If payment has customer email, the link is sent via email. If payment has customer phone, the link is sent via WhatsApp, if the phone number is not registered in WhatsApp, the link is sent via SMS. 
     * @summary Send Payment Link
     * @param {string} id The payment ID
     * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public sendLink(id: string, sendPaymentLinkRequest?: SendPaymentLinkRequest, options?: any) {
        return PaymentsApiFp(this.configuration).sendLink(id, sendPaymentLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a payment receipt to the customer. If payment has customer email, the receipt is sent via email. If payment has customer phone, the receipt is sent via WhatsApp, if the phone number is not registered in WhatsApp, the receipt is sent via SMS. 
     * @summary Send Payment Receipt
     * @param {string} id The payment ID
     * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public sendReceipt(id: string, sendPaymentReceiptRequest?: SendPaymentReceiptRequest, options?: any) {
        return PaymentsApiFp(this.configuration).sendReceipt(id, sendPaymentReceiptRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a payment request directly to the customer\'s phone. If Bizum payment method is available and the phone number is registered in Bizum, the customer will get a push notification to confirm the payment directly in the banking app, otherwise, he will receive a link to pay via WhatsApp. 
     * @summary Send Payment Request
     * @param {string} id The payment ID
     * @param {SendPaymentRequest} sendPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public sendRequest(id: string, sendPaymentRequest: SendPaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).sendRequest(id, sendPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activates the subscription that was previously created. Activation of the subscription will create an initial payment. If the subscription has trial period, the initial payment will have zero amount. The subscription is automatically activated when initial payment is confirmed.  If the subscription is already activated, this endpoint can be used to update payment method. This will also generate zero amount payment. 
         * @summary Activate Subscription
         * @param {string} id The subscription ID
         * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate: async (id: string, activateSubscriptionRequest?: ActivateSubscriptionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling activate.');
            }
            const localVarPath = `/subscriptions/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateSubscriptionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateSubscriptionRequest !== undefined ? activateSubscriptionRequest : {}) : (activateSubscriptionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels the activate subscription. 
         * @summary Cancel Subscription
         * @param {string} id The subscription ID
         * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, cancelSubscriptionRequest?: CancelSubscriptionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cancel.');
            }
            const localVarPath = `/subscriptions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof cancelSubscriptionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cancelSubscriptionRequest !== undefined ? cancelSubscriptionRequest : {}) : (cancelSubscriptionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new subscription. Subscription is created with status: `PENDING`. In order to activate it you need to call [activate endpoint](#operation/subscriptions_activate). 
         * @summary Create Subscription
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createSubscriptionRequest: CreateSubscriptionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSubscriptionRequest' is not null or undefined
            if (createSubscriptionRequest === null || createSubscriptionRequest === undefined) {
                throw new RequiredError('createSubscriptionRequest','Required parameter createSubscriptionRequest was null or undefined when calling create.');
            }
            const localVarPath = `/subscriptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createSubscriptionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createSubscriptionRequest !== undefined ? createSubscriptionRequest : {}) : (createSubscriptionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a subscription that has previously been created. Supply the unique subscription ID that was returned from your previous request. 
         * @summary Get Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pauses the active subscription. 
         * @summary Pause Subscription
         * @param {string} id The subscription ID
         * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause: async (id: string, pauseSubscriptionRequest?: PauseSubscriptionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pause.');
            }
            const localVarPath = `/subscriptions/{id}/pause`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof pauseSubscriptionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(pauseSubscriptionRequest !== undefined ? pauseSubscriptionRequest : {}) : (pauseSubscriptionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes the paused subscription. 
         * @summary Resume Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resume.');
            }
            const localVarPath = `/subscriptions/{id}/resume`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing subscription. Supply the unique subscription ID that was returned from your previous request. 
         * @summary Update Subscription
         * @param {string} id The subscription ID
         * @param {UpdateSubscriptionRequest} updateSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling update.');
            }
            // verify required parameter 'updateSubscriptionRequest' is not null or undefined
            if (updateSubscriptionRequest === null || updateSubscriptionRequest === undefined) {
                throw new RequiredError('updateSubscriptionRequest','Required parameter updateSubscriptionRequest was null or undefined when calling update.');
            }
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateSubscriptionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateSubscriptionRequest !== undefined ? updateSubscriptionRequest : {}) : (updateSubscriptionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Activates the subscription that was previously created. Activation of the subscription will create an initial payment. If the subscription has trial period, the initial payment will have zero amount. The subscription is automatically activated when initial payment is confirmed.  If the subscription is already activated, this endpoint can be used to update payment method. This will also generate zero amount payment. 
         * @summary Activate Subscription
         * @param {string} id The subscription ID
         * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activate(id: string, activateSubscriptionRequest?: ActivateSubscriptionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await SubscriptionsApiAxiosParamCreator(configuration).activate(id, activateSubscriptionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cancels the activate subscription. 
         * @summary Cancel Subscription
         * @param {string} id The subscription ID
         * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, cancelSubscriptionRequest?: CancelSubscriptionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await SubscriptionsApiAxiosParamCreator(configuration).cancel(id, cancelSubscriptionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new subscription. Subscription is created with status: `PENDING`. In order to activate it you need to call [activate endpoint](#operation/subscriptions_activate). 
         * @summary Create Subscription
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createSubscriptionRequest: CreateSubscriptionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await SubscriptionsApiAxiosParamCreator(configuration).create(createSubscriptionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the details of a subscription that has previously been created. Supply the unique subscription ID that was returned from your previous request. 
         * @summary Get Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await SubscriptionsApiAxiosParamCreator(configuration).get(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Pauses the active subscription. 
         * @summary Pause Subscription
         * @param {string} id The subscription ID
         * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pause(id: string, pauseSubscriptionRequest?: PauseSubscriptionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await SubscriptionsApiAxiosParamCreator(configuration).pause(id, pauseSubscriptionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Resumes the paused subscription. 
         * @summary Resume Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resume(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await SubscriptionsApiAxiosParamCreator(configuration).resume(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing subscription. Supply the unique subscription ID that was returned from your previous request. 
         * @summary Update Subscription
         * @param {string} id The subscription ID
         * @param {UpdateSubscriptionRequest} updateSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await SubscriptionsApiAxiosParamCreator(configuration).update(id, updateSubscriptionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Activates the subscription that was previously created. Activation of the subscription will create an initial payment. If the subscription has trial period, the initial payment will have zero amount. The subscription is automatically activated when initial payment is confirmed.  If the subscription is already activated, this endpoint can be used to update payment method. This will also generate zero amount payment. 
         * @summary Activate Subscription
         * @param {string} id The subscription ID
         * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate(id: string, activateSubscriptionRequest?: ActivateSubscriptionRequest, options?: any): AxiosPromise<Payment> {
            return SubscriptionsApiFp(configuration).activate(id, activateSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels the activate subscription. 
         * @summary Cancel Subscription
         * @param {string} id The subscription ID
         * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, cancelSubscriptionRequest?: CancelSubscriptionRequest, options?: any): AxiosPromise<Subscription> {
            return SubscriptionsApiFp(configuration).cancel(id, cancelSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new subscription. Subscription is created with status: `PENDING`. In order to activate it you need to call [activate endpoint](#operation/subscriptions_activate). 
         * @summary Create Subscription
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createSubscriptionRequest: CreateSubscriptionRequest, options?: any): AxiosPromise<Subscription> {
            return SubscriptionsApiFp(configuration).create(createSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a subscription that has previously been created. Supply the unique subscription ID that was returned from your previous request. 
         * @summary Get Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: any): AxiosPromise<Subscription> {
            return SubscriptionsApiFp(configuration).get(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Pauses the active subscription. 
         * @summary Pause Subscription
         * @param {string} id The subscription ID
         * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(id: string, pauseSubscriptionRequest?: PauseSubscriptionRequest, options?: any): AxiosPromise<Subscription> {
            return SubscriptionsApiFp(configuration).pause(id, pauseSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes the paused subscription. 
         * @summary Resume Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(id: string, options?: any): AxiosPromise<Subscription> {
            return SubscriptionsApiFp(configuration).resume(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing subscription. Supply the unique subscription ID that was returned from your previous request. 
         * @summary Update Subscription
         * @param {string} id The subscription ID
         * @param {UpdateSubscriptionRequest} updateSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, options?: any): AxiosPromise<Subscription> {
            return SubscriptionsApiFp(configuration).update(id, updateSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * Activates the subscription that was previously created. Activation of the subscription will create an initial payment. If the subscription has trial period, the initial payment will have zero amount. The subscription is automatically activated when initial payment is confirmed.  If the subscription is already activated, this endpoint can be used to update payment method. This will also generate zero amount payment. 
     * @summary Activate Subscription
     * @param {string} id The subscription ID
     * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public activate(id: string, activateSubscriptionRequest?: ActivateSubscriptionRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).activate(id, activateSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels the activate subscription. 
     * @summary Cancel Subscription
     * @param {string} id The subscription ID
     * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public cancel(id: string, cancelSubscriptionRequest?: CancelSubscriptionRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).cancel(id, cancelSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new subscription. Subscription is created with status: `PENDING`. In order to activate it you need to call [activate endpoint](#operation/subscriptions_activate). 
     * @summary Create Subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public create(createSubscriptionRequest: CreateSubscriptionRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).create(createSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a subscription that has previously been created. Supply the unique subscription ID that was returned from your previous request. 
     * @summary Get Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public get(id: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).get(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pauses the active subscription. 
     * @summary Pause Subscription
     * @param {string} id The subscription ID
     * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public pause(id: string, pauseSubscriptionRequest?: PauseSubscriptionRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).pause(id, pauseSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes the paused subscription. 
     * @summary Resume Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public resume(id: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).resume(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing subscription. Supply the unique subscription ID that was returned from your previous request. 
     * @summary Update Subscription
     * @param {string} id The subscription ID
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public update(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).update(id, updateSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


