/* tslint:disable */
/* eslint-disable */
/**
 * MONEI API v1
 * <p>The MONEI API is organized around <a href=\"https://en.wikipedia.org/wiki/Representational_State_Transfer\">REST</a> principles. Our API is designed to be intuitive and developer-friendly.</p> <h3>Base URL</h3> <p>All API requests should be made to:</p> <pre><code>https://api.monei.com/v1 </code></pre> <h3>Environment</h3> <p>MONEI provides two environments:</p> <ul> <li><strong>Test Environment</strong>: For development and testing without processing real payments</li> <li><strong>Live Environment</strong>: For processing real transactions in production</li> </ul> <h3>Client Libraries</h3> <p>We provide official SDKs to simplify integration:</p> <ul> <li><a href=\"https://github.com/MONEI/monei-php-sdk\">PHP SDK</a></li> <li><a href=\"https://github.com/MONEI/monei-python-sdk\">Python SDK</a></li> <li><a href=\"https://github.com/MONEI/monei-node-sdk\">Node.js SDK</a></li> <li><a href=\"https://postman.monei.com/\">Postman Collection</a></li> </ul> <p>Our SDKs handle authentication, error handling, and request formatting automatically.</p> <p>You can download the OpenAPI specification from the <a href=\"https://js.monei.com/api/v1/openapi.json\">https://js.monei.com/api/v1/openapi.json</a> and generate your own client library using the <a href=\"https://openapi-generator.tech/\">OpenAPI Generator</a>.</p> <h3>Important Requirements</h3> <ul> <li>All API requests must be made over HTTPS</li> <li>If you are not using our official SDKs, you <strong>must provide a valid <code>User-Agent</code> header</strong> with each request</li> <li>Requests without proper authentication will return a <code>401 Unauthorized</code> error</li> </ul> <h3>Error Handling</h3> <p>The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a <code>statusCode</code> attribute indicating the outcome of your request.</p> <h3>Rate Limits</h3> <p>The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a <code>429 Too Many Requests</code> status code.</p> 
 *
 * The version of the OpenAPI document: 1.5.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from '../axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivateSubscriptionRequest
 */
export interface ActivateSubscriptionRequest {
    /**
     * A payment token generated by monei.js [Components](https://docs.monei.com/docs/monei-js-overview) or a paymentToken [saved after a previous successful payment](https://docs.monei.com/docs/save-payment-method). In case of the first one, you will also need to send the `sessionId` used to generate the token in the first place. 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    'paymentToken'?: string;
    /**
     * A unique identifier within your system that adds security to the payment process. You need to pass the same session ID as the one used on the frontend to initialize MONEI Component (if you needed to). This is required if a payment token (not permanent) was already generated in the frontend. 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    'sessionId'?: string;
    /**
     * The amount to be added to the subscription\'s initial payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof ActivateSubscriptionRequest
     */
    'addAmount'?: number;
    /**
     * A permanent identifier that refers to the initial payment of a sequence of payments. This value needs to be sent in the path for `RECURRING` payments. 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    'sequenceId'?: string;
    /**
     * The URL the customer will be directed to after transaction completed (successful or failed - except if `failUrl` is provided). 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    'completeUrl'?: string;
    /**
     * The URL the customer will be directed to after transaction has failed, instead of `completeUrl` (used in hosted payment page). This allows to provide two different URLs for successful and failed payments. 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    'failUrl'?: string;
    /**
     * The URL the customer will be directed to if they decide to cancel payment and return to your website (used in hosted payment page). 
     * @type {string}
     * @memberof ActivateSubscriptionRequest
     */
    'cancelUrl'?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof ActivateSubscriptionRequest
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
    /**
     * City, district, suburb, town, or village.
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * Address line 1 (e.g., street, PO Box, or company name).
     * @type {string}
     * @memberof Address
     */
    'line1'?: string;
    /**
     * Address line 2 (e.g., apartment, suite, unit, or building).
     * @type {string}
     * @memberof Address
     */
    'line2'?: string;
    /**
     * ZIP or postal code.
     * @type {string}
     * @memberof Address
     */
    'zip'?: string;
    /**
     * State, county, province, or region.
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface ApplePayDomainRegister200Response
 */
export interface ApplePayDomainRegister200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApplePayDomainRegister200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface BizumValidatePhone200Response
 */
export interface BizumValidatePhone200Response {
    /**
     * 
     * @type {boolean}
     * @memberof BizumValidatePhone200Response
     */
    'isValid'?: boolean;
}
/**
 * 
 * @export
 * @interface CancelPaymentRequest
 */
export interface CancelPaymentRequest {
    /**
     * 
     * @type {PaymentCancellationReason}
     * @memberof CancelPaymentRequest
     */
    'cancellationReason'?: PaymentCancellationReason;
}


/**
 * 
 * @export
 * @interface CancelSubscriptionRequest
 */
export interface CancelSubscriptionRequest {
    /**
     * If true, the subscription will be canceled at the end of the current period. 
     * @type {boolean}
     * @memberof CancelSubscriptionRequest
     */
    'cancelAtPeriodEnd'?: boolean;
}
/**
 * 
 * @export
 * @interface CapturePaymentRequest
 */
export interface CapturePaymentRequest {
    /**
     * The amount to capture, which must be less than or equal to the original amount. Any additional amount will be automatically refunded. 
     * @type {number}
     * @memberof CapturePaymentRequest
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface ConfirmPaymentRequest
 */
export interface ConfirmPaymentRequest {
    /**
     * A payment token generated by monei.js [Components](https://docs.monei.com/docs/monei-js-overview) or a paymentToken [saved after a previous successful payment](https://docs.monei.com/docs/save-payment-method). 
     * @type {string}
     * @memberof ConfirmPaymentRequest
     */
    'paymentToken': string;
    /**
     * 
     * @type {ConfirmPaymentRequestPaymentMethod}
     * @memberof ConfirmPaymentRequest
     */
    'paymentMethod'?: ConfirmPaymentRequestPaymentMethod;
    /**
     * If set to true a permanent token that represents a payment method used in the payment will be generated. 
     * @type {boolean}
     * @memberof ConfirmPaymentRequest
     */
    'generatePaymentToken'?: boolean;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof ConfirmPaymentRequest
     */
    'customer'?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof ConfirmPaymentRequest
     */
    'billingDetails'?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof ConfirmPaymentRequest
     */
    'shippingDetails'?: PaymentShippingDetails;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof ConfirmPaymentRequest
     */
    'metadata'?: object;
}
/**
 * Additional information about the payment method used for this payment.
 * @export
 * @interface ConfirmPaymentRequestPaymentMethod
 */
export interface ConfirmPaymentRequestPaymentMethod {
    /**
     * 
     * @type {ConfirmPaymentRequestPaymentMethodCard}
     * @memberof ConfirmPaymentRequestPaymentMethod
     */
    'card'?: ConfirmPaymentRequestPaymentMethodCard;
}
/**
 * Additional information about the card used for this payment.
 * @export
 * @interface ConfirmPaymentRequestPaymentMethodCard
 */
export interface ConfirmPaymentRequestPaymentMethodCard {
    /**
     * The cardholder\'s name, as stated in the credit card.
     * @type {string}
     * @memberof ConfirmPaymentRequestPaymentMethodCard
     */
    'cardholderName'?: string;
    /**
     * The cardholder\'s email address.
     * @type {string}
     * @memberof ConfirmPaymentRequestPaymentMethodCard
     */
    'cardholderEmail'?: string;
}
/**
 * 
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof CreatePaymentRequest
     */
    'amount': number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'currency': string;
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'orderId': string;
    /**
     * The URL to which a payment result should be sent asynchronously. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'callbackUrl'?: string;
    /**
     * The URL the customer will be directed to after transaction completed (successful or failed - except if `failUrl` is provided). 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'completeUrl'?: string;
    /**
     * The URL the customer will be directed to after transaction has failed, instead of `completeUrl` (used in hosted payment page). This allows to provide two different URLs for successful and failed payments. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'failUrl'?: string;
    /**
     * The URL the customer will be directed to if they decide to cancel payment and return to your website (used in hosted payment page). 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'cancelUrl'?: string;
    /**
     * A payment token generated by monei.js [Components](https://docs.monei.com/docs/monei-js-overview) or a paymentToken [saved after a previous successful payment](https://docs.monei.com/docs/save-payment-method). In case of the first one, you will also need to send the `sessionId` used to generate the token in the first place. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'paymentToken'?: string;
    /**
     * A unique identifier within your system that adds security to the payment process. You need to pass the same session ID as the one used on the frontend to initialize MONEI Component (if you needed to). This is required if a payment token (not permanent) was already generated in the frontend. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'sessionId'?: string;
    /**
     * If set to true a permanent token that represents a payment method used in the payment will be generated. 
     * @type {boolean}
     * @memberof CreatePaymentRequest
     */
    'generatePaymentToken'?: boolean;
    /**
     * 
     * @type {PaymentPaymentMethodInput}
     * @memberof CreatePaymentRequest
     */
    'paymentMethod'?: PaymentPaymentMethodInput;
    /**
     * 
     * @type {PaymentPaymentMethods}
     * @memberof CreatePaymentRequest
     */
    'allowedPaymentMethods'?: PaymentPaymentMethods;
    /**
     * 
     * @type {PaymentTransactionType}
     * @memberof CreatePaymentRequest
     */
    'transactionType'?: PaymentTransactionType;
    /**
     * 
     * @type {PaymentSequence}
     * @memberof CreatePaymentRequest
     */
    'sequence'?: PaymentSequence;
    /**
     * A unique identifier of the Store. If specified the payment is attached to this Store. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'storeId'?: string;
    /**
     * A unique identifier of the Point of Sale. If specified the payment is attached to this Point of Sale. If there is a QR code attached to the same Point of Sale, this payment will be available by scanning the QR code. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'pointOfSaleId'?: string;
    /**
     * A unique identifier of the Subscription. If specified the payment is attached to this Subscription. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'subscriptionId'?: string;
    /**
     * If set to `true`, the new payment will be automatically created when customer visits the payment link of the previously failed payment. Is automatically set to `true` if `completeUrl` is not provided.(set this value to `true` to create \"Pay By Link\" payments).
     * @type {boolean}
     * @memberof CreatePaymentRequest
     */
    'autoRecover'?: boolean;
    /**
     * An arbitrary string attached to the payment. Often useful for displaying to users. 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof CreatePaymentRequest
     */
    'customer'?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof CreatePaymentRequest
     */
    'billingDetails'?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof CreatePaymentRequest
     */
    'shippingDetails'?: PaymentShippingDetails;
    /**
     * 
     * @type {PaymentSessionDetails}
     * @memberof CreatePaymentRequest
     */
    'sessionDetails'?: PaymentSessionDetails;
    /**
     * Payment expiration time.
     * @type {number}
     * @memberof CreatePaymentRequest
     */
    'expireAt'?: number;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof CreatePaymentRequest
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @interface CreateSubscriptionRequest
 */
export interface CreateSubscriptionRequest {
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    'amount': number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency. 
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'currency': string;
    /**
     * 
     * @type {SubscriptionInterval}
     * @memberof CreateSubscriptionRequest
     */
    'interval': SubscriptionInterval;
    /**
     * Number of intervals between subscription payments.
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    'intervalCount'?: number;
    /**
     * An arbitrary string attached to the subscription. Often useful for displaying to users. 
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof CreateSubscriptionRequest
     */
    'customer'?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof CreateSubscriptionRequest
     */
    'billingDetails'?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof CreateSubscriptionRequest
     */
    'shippingDetails'?: PaymentShippingDetails;
    /**
     * The end date of the trial period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    'trialPeriodEnd'?: number;
    /**
     * Number of days the trial period lasts.
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    'trialPeriodDays'?: number;
    /**
     * 
     * @type {SubscriptionRetrySchedule}
     * @memberof CreateSubscriptionRequest
     */
    'retrySchedule'?: SubscriptionRetrySchedule;
    /**
     * The URL will be called each time subscription status changes. You will receive a subscription object in the body of the request. 
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'callbackUrl'?: string;
    /**
     * The URL will be called each time subscription creates a new payments. You will receive the payment object in the body of the request. 
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'paymentCallbackUrl'?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof CreateSubscriptionRequest
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error type identifier
     * @type {string}
     * @memberof ModelError
     */
    'status': string;
    /**
     * HTTP status code
     * @type {number}
     * @memberof ModelError
     */
    'statusCode': number;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * Unique identifier for the request
     * @type {string}
     * @memberof ModelError
     */
    'requestId': string;
    /**
     * Timestamp when the request was processed
     * @type {string}
     * @memberof ModelError
     */
    'requestTime': string;
}
/**
 * 
 * @export
 * @interface PauseSubscriptionRequest
 */
export interface PauseSubscriptionRequest {
    /**
     * If true, the subscription will be paused at the end of the current period. 
     * @type {boolean}
     * @memberof PauseSubscriptionRequest
     */
    'pauseAtPeriodEnd'?: boolean;
    /**
     * Number of intervals when subscription will be paused before it activates again.
     * @type {number}
     * @memberof PauseSubscriptionRequest
     */
    'pauseIntervalCount'?: number;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * Unique identifier for the payment.
     * @type {string}
     * @memberof Payment
     */
    'id'?: string;
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof Payment
     */
    'amount'?: number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency. 
     * @type {string}
     * @memberof Payment
     */
    'currency'?: string;
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system. 
     * @type {string}
     * @memberof Payment
     */
    'orderId'?: string;
    /**
     * An arbitrary string attached to the payment. Often useful for displaying to users. 
     * @type {string}
     * @memberof Payment
     */
    'description'?: string;
    /**
     * MONEI Account identifier.
     * @type {string}
     * @memberof Payment
     */
    'accountId'?: string;
    /**
     * Unique identifier provided by the bank performing transaction. 
     * @type {string}
     * @memberof Payment
     */
    'authorizationCode'?: string;
    /**
     * Has the value `true` if the resource exists in live mode or the value `false` if the resource exists in test mode.
     * @type {boolean}
     * @memberof Payment
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof Payment
     */
    'status'?: PaymentStatus;
    /**
     * Payment status code. 
     * @type {string}
     * @memberof Payment
     */
    'statusCode'?: string;
    /**
     * Human readable status message, can be displayed to a user. 
     * @type {string}
     * @memberof Payment
     */
    'statusMessage'?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof Payment
     */
    'customer'?: PaymentCustomer;
    /**
     * 
     * @type {PaymentShop}
     * @memberof Payment
     */
    'shop'?: PaymentShop;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof Payment
     */
    'billingDetails'?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof Payment
     */
    'shippingDetails'?: PaymentShippingDetails;
    /**
     * Amount in cents refunded (can be less than the amount attribute on the payment if a partial refund was issued). 
     * @type {number}
     * @memberof Payment
     */
    'refundedAmount'?: number;
    /**
     * Amount in cents refunded in the last transaction.
     * @type {number}
     * @memberof Payment
     */
    'lastRefundAmount'?: number;
    /**
     * 
     * @type {PaymentLastRefundReason}
     * @memberof Payment
     */
    'lastRefundReason'?: PaymentLastRefundReason;
    /**
     * 
     * @type {PaymentCancellationReason}
     * @memberof Payment
     */
    'cancellationReason'?: PaymentCancellationReason;
    /**
     * 
     * @type {PaymentSessionDetails}
     * @memberof Payment
     */
    'sessionDetails'?: PaymentSessionDetails;
    /**
     * 
     * @type {PaymentTraceDetails}
     * @memberof Payment
     */
    'traceDetails'?: PaymentTraceDetails;
    /**
     * A permanent token represents a payment method used in the payment. Pass `generatePaymentToken: true` when you creating a payment to generate it. You can pass it as `paymentToken` parameter to create other payments with the same payment method. This token does not expire, and should only be used server-side. 
     * @type {string}
     * @memberof Payment
     */
    'paymentToken'?: string;
    /**
     * 
     * @type {PaymentPaymentMethod}
     * @memberof Payment
     */
    'paymentMethod'?: PaymentPaymentMethod;
    /**
     * 
     * @type {PaymentSequence}
     * @memberof Payment
     */
    'sequence'?: PaymentSequence;
    /**
     * A permanent identifier that refers to the initial payment of a sequence of payments. This value needs to be sent in the path for `RECURRING` payments. 
     * @type {string}
     * @memberof Payment
     */
    'sequenceId'?: string;
    /**
     * A unique identifier of the Store. If specified the payment is attached to this Store. 
     * @type {string}
     * @memberof Payment
     */
    'storeId'?: string;
    /**
     * A unique identifier of the Point of Sale. If specified the payment is attached to this Point of Sale. If there is a QR code attached to the same Point of Sale, this payment will be available by scanning the QR code. 
     * @type {string}
     * @memberof Payment
     */
    'pointOfSaleId'?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof Payment
     */
    'metadata'?: object;
    /**
     * 
     * @type {PaymentNextAction}
     * @memberof Payment
     */
    'nextAction'?: PaymentNextAction;
    /**
     * Time at which the resource was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Payment
     */
    'createdAt'?: number;
    /**
     * Time at which the resource updated last time. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Payment
     */
    'updatedAt'?: number;
}


/**
 * Billing information associated with the payment method at the time of the transaction. 
 * @export
 * @interface PaymentBillingDetails
 */
export interface PaymentBillingDetails {
    /**
     * The customer\'s billing full name.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    'name'?: string;
    /**
     * The customer\'s billing email address.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    'email'?: string;
    /**
     * The customer\'s billing phone number in E.164 format.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    'phone'?: string;
    /**
     * Billing company name.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    'company'?: string;
    /**
     * Company tax ID.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    'taxId'?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentBillingDetails
     */
    'address'?: Address;
}
/**
 * The reason for canceling the Payment.
 * @export
 * @enum {string}
 */

export const PaymentCancellationReason = {
    duplicated: 'duplicated',
    fraudulent: 'fraudulent',
    requested_by_customer: 'requested_by_customer'
} as const;

export type PaymentCancellationReason = typeof PaymentCancellationReason[keyof typeof PaymentCancellationReason];


/**
 * 
 * @export
 * @interface PaymentCustomer
 */
export interface PaymentCustomer {
    /**
     * The customer\'s email address.
     * @type {string}
     * @memberof PaymentCustomer
     */
    'email'?: string;
    /**
     * The customer\'s full name or business name.
     * @type {string}
     * @memberof PaymentCustomer
     */
    'name'?: string;
    /**
     * The customer\'s phone number in E.164 format.
     * @type {string}
     * @memberof PaymentCustomer
     */
    'phone'?: string;
}
/**
 * The reason of the last refund transaction.
 * @export
 * @enum {string}
 */

export const PaymentLastRefundReason = {
    duplicated: 'duplicated',
    fraudulent: 'fraudulent',
    requested_by_customer: 'requested_by_customer'
} as const;

export type PaymentLastRefundReason = typeof PaymentLastRefundReason[keyof typeof PaymentLastRefundReason];


/**
 * The channel used to send the payment message. 
 * @export
 * @enum {string}
 */

export const PaymentMessageChannel = {
    EMAIL: 'EMAIL',
    WHATSAPP: 'WHATSAPP',
    SMS: 'SMS'
} as const;

export type PaymentMessageChannel = typeof PaymentMessageChannel[keyof typeof PaymentMessageChannel];


/**
 * The language of message sent to the customer. If not provided the default customer language is used if available.
 * @export
 * @enum {string}
 */

export const PaymentMessageLanguage = {
    en: 'en',
    es: 'es',
    ca: 'ca',
    pt: 'pt',
    de: 'de',
    it: 'it',
    fr: 'fr'
} as const;

export type PaymentMessageLanguage = typeof PaymentMessageLanguage[keyof typeof PaymentMessageLanguage];


/**
 * 
 * @export
 * @interface PaymentMethods
 */
export interface PaymentMethods {
    /**
     * Has the value `true` if the resource exists in live mode or the value `false` if the resource exists in test mode.
     * @type {boolean}
     * @memberof PaymentMethods
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {PaymentMethodsMethods}
     * @memberof PaymentMethods
     */
    'paymentMethods'?: PaymentMethodsMethods;
    /**
     * 
     * @type {PaymentMethodsMetadata}
     * @memberof PaymentMethods
     */
    'metadata'?: PaymentMethodsMetadata;
    /**
     * The name of the merchant
     * @type {string}
     * @memberof PaymentMethods
     */
    'merchantName'?: string;
    /**
     * The URL of the merchant\'s website
     * @type {string}
     * @memberof PaymentMethods
     */
    'merchantUrl'?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentMethods
     */
    'countryCode'?: string;
    /**
     * MONEI Account identifier.
     * @type {string}
     * @memberof PaymentMethods
     */
    'accountId'?: string;
    /**
     * The amount of the payment in the smallest currency unit. For example, 10 EUR = 1000 cents. Only present when querying by paymentId. 
     * @type {number}
     * @memberof PaymentMethods
     */
    'amount'?: number;
    /**
     * Three-letter ISO currency code, in uppercase. Only present when querying by paymentId. 
     * @type {string}
     * @memberof PaymentMethods
     */
    'currency'?: string;
}
/**
 * Additional configuration details for each payment method. 
 * @export
 * @interface PaymentMethodsMetadata
 */
export interface PaymentMethodsMetadata {
    /**
     * 
     * @type {PaymentMethodsMetadataAlipay}
     * @memberof PaymentMethodsMetadata
     */
    'alipay'?: PaymentMethodsMetadataAlipay;
    /**
     * 
     * @type {PaymentMethodsMetadataBancontact}
     * @memberof PaymentMethodsMetadata
     */
    'bancontact'?: PaymentMethodsMetadataBancontact;
    /**
     * 
     * @type {PaymentMethodsMetadataBizum}
     * @memberof PaymentMethodsMetadata
     */
    'bizum'?: PaymentMethodsMetadataBizum;
    /**
     * 
     * @type {PaymentMethodsMetadataBlik}
     * @memberof PaymentMethodsMetadata
     */
    'blik'?: PaymentMethodsMetadataBlik;
    /**
     * 
     * @type {PaymentMethodsMetadataCard}
     * @memberof PaymentMethodsMetadata
     */
    'card'?: PaymentMethodsMetadataCard;
    /**
     * 
     * @type {PaymentMethodsMetadataEps}
     * @memberof PaymentMethodsMetadata
     */
    'eps'?: PaymentMethodsMetadataEps;
    /**
     * 
     * @type {PaymentMethodsMetadataIDeal}
     * @memberof PaymentMethodsMetadata
     */
    'iDeal'?: PaymentMethodsMetadataIDeal;
    /**
     * 
     * @type {PaymentMethodsMetadataMbway}
     * @memberof PaymentMethodsMetadata
     */
    'mbway'?: PaymentMethodsMetadataMbway;
    /**
     * 
     * @type {PaymentMethodsMetadataMbway}
     * @memberof PaymentMethodsMetadata
     */
    'multibanco'?: PaymentMethodsMetadataMbway;
    /**
     * 
     * @type {PaymentMethodsMetadataSofort}
     * @memberof PaymentMethodsMetadata
     */
    'sofort'?: PaymentMethodsMetadataSofort;
    /**
     * 
     * @type {PaymentMethodsMetadataTrustly}
     * @memberof PaymentMethodsMetadata
     */
    'trustly'?: PaymentMethodsMetadataTrustly;
    /**
     * 
     * @type {PaymentMethodsMetadataSepa}
     * @memberof PaymentMethodsMetadata
     */
    'sepa'?: PaymentMethodsMetadataSepa;
    /**
     * 
     * @type {PaymentMethodsMetadataKlarna}
     * @memberof PaymentMethodsMetadata
     */
    'klarna'?: PaymentMethodsMetadataKlarna;
    /**
     * 
     * @type {PaymentMethodsMetadataGiropay}
     * @memberof PaymentMethodsMetadata
     */
    'giropay'?: PaymentMethodsMetadataGiropay;
    /**
     * 
     * @type {PaymentMethodsMetadataGooglePay}
     * @memberof PaymentMethodsMetadata
     */
    'googlePay'?: PaymentMethodsMetadataGooglePay;
    /**
     * 
     * @type {PaymentMethodsMetadataApplePay}
     * @memberof PaymentMethodsMetadata
     */
    'applePay'?: PaymentMethodsMetadataApplePay;
    /**
     * 
     * @type {PaymentMethodsMetadataClickToPay}
     * @memberof PaymentMethodsMetadata
     */
    'clickToPay'?: PaymentMethodsMetadataClickToPay;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataAlipay
 */
export interface PaymentMethodsMetadataAlipay {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataAlipay
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataApplePay
 */
export interface PaymentMethodsMetadataApplePay {
    /**
     * Apple Pay merchant ID
     * @type {string}
     * @memberof PaymentMethodsMetadataApplePay
     */
    'merchantId'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataBancontact
 */
export interface PaymentMethodsMetadataBancontact {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataBancontact
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataBizum
 */
export interface PaymentMethodsMetadataBizum {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataBizum
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataBlik
 */
export interface PaymentMethodsMetadataBlik {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataBlik
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataCard
 */
export interface PaymentMethodsMetadataCard {
    /**
     * List of card brands supported
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataCard
     */
    'brands'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataClickToPay
 */
export interface PaymentMethodsMetadataClickToPay {
    /**
     * Whether token support is enabled
     * @type {boolean}
     * @memberof PaymentMethodsMetadataClickToPay
     */
    'tokenSupport'?: boolean;
    /**
     * Whether the method is preselected
     * @type {boolean}
     * @memberof PaymentMethodsMetadataClickToPay
     */
    'preselected'?: boolean;
    /**
     * 
     * @type {PaymentMethodsMetadataClickToPayVisa}
     * @memberof PaymentMethodsMetadataClickToPay
     */
    'visa'?: PaymentMethodsMetadataClickToPayVisa;
    /**
     * 
     * @type {PaymentMethodsMetadataClickToPayMastercard}
     * @memberof PaymentMethodsMetadataClickToPay
     */
    'mastercard'?: PaymentMethodsMetadataClickToPayMastercard;
    /**
     * 
     * @type {PaymentMethodsMetadataClickToPayDiscover}
     * @memberof PaymentMethodsMetadataClickToPay
     */
    'discover'?: PaymentMethodsMetadataClickToPayDiscover;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataClickToPayDiscover
 */
export interface PaymentMethodsMetadataClickToPayDiscover {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodsMetadataClickToPayDiscover
     */
    'srciDpaId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodsMetadataClickToPayDiscover
     */
    'srcInitiatorId'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataClickToPayMastercard
 */
export interface PaymentMethodsMetadataClickToPayMastercard {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodsMetadataClickToPayMastercard
     */
    'srciDpaId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodsMetadataClickToPayMastercard
     */
    'srcInitiatorId'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataClickToPayVisa
 */
export interface PaymentMethodsMetadataClickToPayVisa {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodsMetadataClickToPayVisa
     */
    'srciDpaId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodsMetadataClickToPayVisa
     */
    'srcInitiatorId'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataEps
 */
export interface PaymentMethodsMetadataEps {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataEps
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataGiropay
 */
export interface PaymentMethodsMetadataGiropay {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataGiropay
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataGooglePay
 */
export interface PaymentMethodsMetadataGooglePay {
    /**
     * Google Pay merchant ID
     * @type {string}
     * @memberof PaymentMethodsMetadataGooglePay
     */
    'merchantId'?: string;
    /**
     * Whether CVC is required for Google Pay transactions
     * @type {boolean}
     * @memberof PaymentMethodsMetadataGooglePay
     */
    'cvcRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataIDeal
 */
export interface PaymentMethodsMetadataIDeal {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataIDeal
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataKlarna
 */
export interface PaymentMethodsMetadataKlarna {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataKlarna
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataMbway
 */
export interface PaymentMethodsMetadataMbway {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataMbway
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataSepa
 */
export interface PaymentMethodsMetadataSepa {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataSepa
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataSofort
 */
export interface PaymentMethodsMetadataSofort {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataSofort
     */
    'countries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaymentMethodsMetadataTrustly
 */
export interface PaymentMethodsMetadataTrustly {
    /**
     * List of countries where the payment method is available
     * @type {Array<string>}
     * @memberof PaymentMethodsMetadataTrustly
     */
    'countries'?: Array<string>;
}
/**
 * An array of available payment methods for the account or payment. Possible values include:   - `alipay` - Alipay   - `applePay` - Apple Pay   - `bancontact` - Bancontact   - `bizum` - Bizum   - `blik` - BLIK   - `card` - Credit or debit card   - `cardPresent` - Card present (physical POS)   - `clickToPay` - Click to Pay   - `cofidis` - Cofidis   - `cofidisLoan` - Cofidis Loan   - `eps` - EPS   - `giropay` - Giropay   - `googlePay` - Google Pay   - `iDeal` - iDEAL   - `klarna` - Klarna   - `mbway` - MB WAY   - `multibanco` - Multibanco   - `paypal` - PayPal   - `sepa` - SEPA Direct Debit   - `sofort` - Sofort   - `trustly` - Trustly 
 * @export
 * @interface PaymentMethodsMethods
 */
export interface PaymentMethodsMethods extends Array<string> {
}
/**
 * If present, this property tells you what actions you need to take in order for your customer to fulfill a payment using the provided source. 
 * @export
 * @interface PaymentNextAction
 */
export interface PaymentNextAction {
    /**
     * - `CONFIRM` - Your customer needs to be redirected to a   [hosted payment page](https://docs.monei.com/docs/use-prebuilt-payment-page)   or confirm payment using   [payment token](https://docs.monei.com/docs/accept-card-payment#3-submitting-the-payment-to-monei-client-side).   The **redirectUrl** will point to the hosted payment page. - `FRICTIONLESS_CHALLENGE` - Your customer needs to be redirected to the frictionless    3d secure challenge page provided by the bank. The **redirectUrl**    will point to the frictionless 3d secure challenge page provided by the bank. - `CHALLENGE` - Your customer needs to be redirected to the   3d secure challenge page provided by the bank. The **redirectUrl**   will point to the 3d secure challenge page provided by the bank. - `COMPLETE` - The payment is completed. The **redirectUrl** will be   the **completeUrl** if it was provided when the payment was created. - `BIZUM_CHALLENGE` - Your customer will be redirected to the Bizum hosted payment page. 
     * @type {string}
     * @memberof PaymentNextAction
     */
    'type'?: PaymentNextActionTypeEnum;
    /**
     * If `true` you have to redirect your customer to the **redirectUrl** to continue payment process. 
     * @type {boolean}
     * @memberof PaymentNextAction
     */
    'mustRedirect'?: boolean;
    /**
     * Redirect your customer to this url to continue payment process. 
     * @type {string}
     * @memberof PaymentNextAction
     */
    'redirectUrl'?: string;
}

export const PaymentNextActionTypeEnum = {
    CONFIRM: 'CONFIRM',
    CHALLENGE: 'CHALLENGE',
    FRICTIONLESS_CHALLENGE: 'FRICTIONLESS_CHALLENGE',
    BIZUM_CHALLENGE: 'BIZUM_CHALLENGE',
    COMPLETE: 'COMPLETE'
} as const;

export type PaymentNextActionTypeEnum = typeof PaymentNextActionTypeEnum[keyof typeof PaymentNextActionTypeEnum];

/**
 * Details about the payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethod
 */
export interface PaymentPaymentMethod {
    /**
     * Payment method type.
     * @type {string}
     * @memberof PaymentPaymentMethod
     */
    'method'?: PaymentPaymentMethodMethodEnum;
    /**
     * 
     * @type {PaymentPaymentMethodCard}
     * @memberof PaymentPaymentMethod
     */
    'card'?: PaymentPaymentMethodCard;
    /**
     * 
     * @type {PaymentPaymentMethodBizum}
     * @memberof PaymentPaymentMethod
     */
    'bizum'?: PaymentPaymentMethodBizum;
    /**
     * 
     * @type {PaymentPaymentMethodPaypal}
     * @memberof PaymentPaymentMethod
     */
    'paypal'?: PaymentPaymentMethodPaypal;
    /**
     * 
     * @type {PaymentPaymentMethodCofidis}
     * @memberof PaymentPaymentMethod
     */
    'cofidis'?: PaymentPaymentMethodCofidis;
    /**
     * 
     * @type {PaymentPaymentMethodCofidis}
     * @memberof PaymentPaymentMethod
     */
    'cofidisLoan'?: PaymentPaymentMethodCofidis;
    /**
     * 
     * @type {PaymentPaymentMethodMbway}
     * @memberof PaymentPaymentMethod
     */
    'mbway'?: PaymentPaymentMethodMbway;
    /**
     * 
     * @type {PaymentPaymentMethodTrustly}
     * @memberof PaymentPaymentMethod
     */
    'trustly'?: PaymentPaymentMethodTrustly;
    /**
     * 
     * @type {PaymentPaymentMethodSepa}
     * @memberof PaymentPaymentMethod
     */
    'sepa'?: PaymentPaymentMethodSepa;
    /**
     * 
     * @type {PaymentPaymentMethodKlarna}
     * @memberof PaymentPaymentMethod
     */
    'klarna'?: PaymentPaymentMethodKlarna;
}

export const PaymentPaymentMethodMethodEnum = {
    alipay: 'alipay',
    card: 'card',
    bizum: 'bizum',
    paypal: 'paypal',
    cofidis: 'cofidis',
    cofidisLoan: 'cofidisLoan',
    mbway: 'mbway',
    multibanco: 'multibanco',
    iDeal: 'iDeal',
    bancontact: 'bancontact',
    sofort: 'sofort',
    trustly: 'trustly',
    sepa: 'sepa',
    klarna: 'klarna',
    giropay: 'giropay',
    eps: 'eps',
    blik: 'blik'
} as const;

export type PaymentPaymentMethodMethodEnum = typeof PaymentPaymentMethodMethodEnum[keyof typeof PaymentPaymentMethodMethodEnum];

/**
 * Details about the Bizum account used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodBizum
 */
export interface PaymentPaymentMethodBizum {
    /**
     * Phone number in E.164 format used to pay with `bizum`.
     * @type {string}
     * @memberof PaymentPaymentMethodBizum
     */
    'phoneNumber'?: string;
}
/**
 * Details about the Bizum account used for this payment. If provided phone number is valid and registered in Bizum, MONEI will try to confirm the payment directly. 
 * @export
 * @interface PaymentPaymentMethodBizumInput
 */
export interface PaymentPaymentMethodBizumInput {
    /**
     * Phone number in E.164 format used to pay with `bizum`.
     * @type {string}
     * @memberof PaymentPaymentMethodBizumInput
     */
    'phoneNumber'?: string;
}
/**
 * Details about the card used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodCard
 */
export interface PaymentPaymentMethodCard {
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    'country'?: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    'brand'?: PaymentPaymentMethodCardBrandEnum;
    /**
     * Card type `debit` or `credit`.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    'type'?: PaymentPaymentMethodCardTypeEnum;
    /**
     * Whether this transaction used 3D Secure authentication.
     * @type {boolean}
     * @memberof PaymentPaymentMethodCard
     */
    'threeDSecure'?: boolean;
    /**
     * The protocol version of the 3DS challenge.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    'threeDSecureVersion'?: string;
    /**
     * The flow used for 3DS authentication. - `CHALLENGE` - In a challenge flow, the issuer requires additional shopper interaction, either through biometrics, two-factor authentication, or similar methods based on [Strong Customer Authentication (SCA)](https://en.wikipedia.org/wiki/Strong_customer_authentication) factors. - `FRICTIONLESS` - In a frictionless flow, the acquirer, issuer, and card scheme exchange all necessary     information in the background through passive authentication using the shopper\'s device     fingerprint. The transaction is completed without further shopper interaction. - `FRICTIONLESS_CHALLENGE` - This flow is the complete 3DS flow. It is similar to the 3DS frictionless flow but     includes an additional authentication step (challenge) that will be invoked if the     information provided in the data collection step does not suffice to determine the     risk-level of the transaction. - `DIRECT` - This transaction did not require [Strong Customer Authentication (SCA)](https://en.wikipedia.org/wiki/Strong_customer_authentication) due to the low risk 
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    'threeDSecureFlow'?: PaymentPaymentMethodCardThreeDSecureFlowEnum;
    /**
     * Time at which the card will expire. Measured in seconds since the Unix epoch. 
     * @type {number}
     * @memberof PaymentPaymentMethodCard
     */
    'expiration'?: number;
    /**
     * The last four digits of the card.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    'last4'?: string;
    /**
     * The digital wallet used to tokenize the card.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    'tokenizationMethod'?: PaymentPaymentMethodCardTokenizationMethodEnum;
    /**
     * The name of the cardholder.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    'cardholderName'?: string;
    /**
     * The email of the cardholder.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    'cardholderEmail'?: string;
}

export const PaymentPaymentMethodCardBrandEnum = {
    visa: 'visa',
    mastercard: 'mastercard',
    diners: 'diners',
    amex: 'amex',
    jcb: 'jcb',
    unionpay: 'unionpay',
    unknown: 'unknown'
} as const;

export type PaymentPaymentMethodCardBrandEnum = typeof PaymentPaymentMethodCardBrandEnum[keyof typeof PaymentPaymentMethodCardBrandEnum];
export const PaymentPaymentMethodCardTypeEnum = {
    debit: 'debit',
    credit: 'credit'
} as const;

export type PaymentPaymentMethodCardTypeEnum = typeof PaymentPaymentMethodCardTypeEnum[keyof typeof PaymentPaymentMethodCardTypeEnum];
export const PaymentPaymentMethodCardThreeDSecureFlowEnum = {
    CHALLENGE: 'CHALLENGE',
    FRICTIONLESS: 'FRICTIONLESS',
    FRICTIONLESS_CHALLENGE: 'FRICTIONLESS_CHALLENGE',
    DIRECT: 'DIRECT'
} as const;

export type PaymentPaymentMethodCardThreeDSecureFlowEnum = typeof PaymentPaymentMethodCardThreeDSecureFlowEnum[keyof typeof PaymentPaymentMethodCardThreeDSecureFlowEnum];
export const PaymentPaymentMethodCardTokenizationMethodEnum = {
    applePay: 'applePay',
    googlePay: 'googlePay',
    clickToPay: 'clickToPay'
} as const;

export type PaymentPaymentMethodCardTokenizationMethodEnum = typeof PaymentPaymentMethodCardTokenizationMethodEnum[keyof typeof PaymentPaymentMethodCardTokenizationMethodEnum];

/**
 * Details about the card used as payment method. If provided, MONEI will try to confirm the payment directly. 
 * @export
 * @interface PaymentPaymentMethodCardInput
 */
export interface PaymentPaymentMethodCardInput {
    /**
     * The card number, as a string without any separators.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    'number'?: string;
    /**
     * Card security code.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    'cvc'?: string;
    /**
     * Two-digit number representing the card\'s expiration month.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    'expMonth'?: string;
    /**
     * Two-digit number representing the card\'s expiration year.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    'expYear'?: string;
    /**
     * The cardholder\'s name, as stated in the credit card.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    'cardholderName'?: string;
    /**
     * The cardholder\'s email address.
     * @type {string}
     * @memberof PaymentPaymentMethodCardInput
     */
    'cardholderEmail'?: string;
}
/**
 * Details from Cofidis order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodCofidis
 */
export interface PaymentPaymentMethodCofidis {
    /**
     * The Cofidis\' order ID.
     * @type {string}
     * @memberof PaymentPaymentMethodCofidis
     */
    'orderId'?: string;
}
/**
 * An information about a payment method used for this payment. We recommend using `paymentToken` instead, as it is more secure way to pass sensitive payment information. Processing credit card information on your server requires [PCI DSS compliance](https://www.investopedia.com/terms/p/pci-compliance.asp). 
 * @export
 * @interface PaymentPaymentMethodInput
 */
export interface PaymentPaymentMethodInput {
    /**
     * 
     * @type {PaymentPaymentMethodCardInput}
     * @memberof PaymentPaymentMethodInput
     */
    'card'?: PaymentPaymentMethodCardInput;
    /**
     * 
     * @type {PaymentPaymentMethodBizumInput}
     * @memberof PaymentPaymentMethodInput
     */
    'bizum'?: PaymentPaymentMethodBizumInput;
}
/**
 * Details from Klarna order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodKlarna
 */
export interface PaymentPaymentMethodKlarna {
    /**
     * 
     * @type {string}
     * @memberof PaymentPaymentMethodKlarna
     */
    'billingCategory'?: PaymentPaymentMethodKlarnaBillingCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentPaymentMethodKlarna
     */
    'authPaymentMethod'?: PaymentPaymentMethodKlarnaAuthPaymentMethodEnum;
}

export const PaymentPaymentMethodKlarnaBillingCategoryEnum = {
    PAY_LATER: 'PAY_LATER',
    PAY_NOW: 'PAY_NOW',
    SLICE_IT: 'SLICE_IT',
    SLICE_IT_BY_CARD: 'SLICE_IT_BY_CARD'
} as const;

export type PaymentPaymentMethodKlarnaBillingCategoryEnum = typeof PaymentPaymentMethodKlarnaBillingCategoryEnum[keyof typeof PaymentPaymentMethodKlarnaBillingCategoryEnum];
export const PaymentPaymentMethodKlarnaAuthPaymentMethodEnum = {
    invoice: 'invoice',
    fixed_amount: 'fixed_amount',
    pix: 'pix',
    base_account: 'base_account',
    deferred_interest: 'deferred_interest',
    direct_debit: 'direct_debit',
    direct_bank_transfer: 'direct_bank_transfer',
    b2b_invoice: 'b2b_invoice',
    card: 'card',
    slice_it_by_card: 'slice_it_by_card'
} as const;

export type PaymentPaymentMethodKlarnaAuthPaymentMethodEnum = typeof PaymentPaymentMethodKlarnaAuthPaymentMethodEnum[keyof typeof PaymentPaymentMethodKlarnaAuthPaymentMethodEnum];

/**
 * Details from MBWay order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodMbway
 */
export interface PaymentPaymentMethodMbway {
    /**
     * Phone number in E.164 format used to pay with `mbway`.
     * @type {string}
     * @memberof PaymentPaymentMethodMbway
     */
    'phoneNumber'?: string;
}
/**
 * Details from Paypal order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodPaypal
 */
export interface PaymentPaymentMethodPaypal {
    /**
     * The Paypal\'s order ID.
     * @type {string}
     * @memberof PaymentPaymentMethodPaypal
     */
    'orderId'?: string;
}
/**
 * Details from SEPA order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodSepa
 */
export interface PaymentPaymentMethodSepa {
    /**
     * The address of the account holder.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    'accountholderAddress'?: string;
    /**
     * The email of the account holder.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    'accountholderEmail'?: string;
    /**
     * The name of the account holder.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    'accountholderName'?: string;
    /**
     * The country code of the account holder.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    'countryCode'?: string;
    /**
     * The address of the bank.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    'bankAddress'?: string;
    /**
     * The code of the bank.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    'bankCode'?: string;
    /**
     * The name of the bank.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    'bankName'?: string;
    /**
     * The BIC of the bank.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    'bic'?: string;
    /**
     * The last 4 digits of the IBAN.
     * @type {string}
     * @memberof PaymentPaymentMethodSepa
     */
    'last4'?: string;
}
/**
 * Details from Trustly order used as payment method at the time of the transaction. 
 * @export
 * @interface PaymentPaymentMethodTrustly
 */
export interface PaymentPaymentMethodTrustly {
    /**
     * The Trustly\'s customer ID.
     * @type {string}
     * @memberof PaymentPaymentMethodTrustly
     */
    'customerId'?: string;
}
/**
 * An array of allowed payment methods (used in hosted payment page). Must be enabled payment methods. Possible values:   - `alipay`   - `card`   - `bizum`   - `paypal`   - `cofidis`   - `cofidisLoan`   - `mbway`   - `multibanco`   - `iDeal`   - `bancontact`   - `sofort`   - `trustly`   - `sepa`   - `klarna`   - `giropay`   - `eps`   - `blik` 
 * @export
 * @interface PaymentPaymentMethods
 */
export interface PaymentPaymentMethods extends Array<string> {
}
/**
 * The reason for refunding the Payment.
 * @export
 * @enum {string}
 */

export const PaymentRefundReason = {
    duplicated: 'duplicated',
    fraudulent: 'fraudulent',
    requested_by_customer: 'requested_by_customer'
} as const;

export type PaymentRefundReason = typeof PaymentRefundReason[keyof typeof PaymentRefundReason];


/**
 * This field needs to be sent in order to mark the beginning of a sequence of payments (recurring/subscriptions, installments, and so). Specific configurations can be set in the inside properties (`recurring`). 
 * @export
 * @interface PaymentSequence
 */
export interface PaymentSequence {
    /**
     * 
     * @type {string}
     * @memberof PaymentSequence
     */
    'type': PaymentSequenceTypeEnum;
    /**
     * 
     * @type {PaymentSequenceRecurring}
     * @memberof PaymentSequence
     */
    'recurring'?: PaymentSequenceRecurring;
}

export const PaymentSequenceTypeEnum = {
    recurring: 'recurring'
} as const;

export type PaymentSequenceTypeEnum = typeof PaymentSequenceTypeEnum[keyof typeof PaymentSequenceTypeEnum];

/**
 * Specific configurations for recurring payments. Will only be used when `sequence`.`type` is `recurring`. 
 * @export
 * @interface PaymentSequenceRecurring
 */
export interface PaymentSequenceRecurring {
    /**
     * Date after which no further recurring payments will be performed. Must be formatted as `YYYYMMDD`. 
     * @type {string}
     * @memberof PaymentSequenceRecurring
     */
    'expiry'?: string;
    /**
     * The minimum number of **days** between the different recurring payments. 
     * @type {number}
     * @memberof PaymentSequenceRecurring
     */
    'frequency'?: number;
}
/**
 * Information related to the browsing session of the user who initiated the payment. 
 * @export
 * @interface PaymentSessionDetails
 */
export interface PaymentSessionDetails {
    /**
     * The IP address where the operation originated.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'ip'?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'countryCode'?: string;
    /**
     * Two-letter language code ([ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1)).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'lang'?: string;
    /**
     * Device type, could be `desktop`, `mobile`, `smartTV`, `tablet`.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'deviceType'?: string;
    /**
     * Information about the device used for the browser session (e.g., `iPhone`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'deviceModel'?: string;
    /**
     * The browser used in this browser session (e.g., `Mobile Safari`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'browser'?: string;
    /**
     * The version for the browser session (e.g., `13.1.1`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'browserVersion'?: string;
    /**
     * Operation system (e.g., `iOS`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'os'?: string;
    /**
     * Operation system version (e.g., `13.5.1`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'osVersion'?: string;
    /**
     * The source component from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'source'?: string;
    /**
     * The source component version from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'sourceVersion'?: string;
    /**
     * Full user agent string of the browser session.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'userAgent'?: string;
    /**
     * Browser accept header.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'browserAccept'?: string;
    /**
     * The color depth of the browser session (e.g., `24`).
     * @type {number}
     * @memberof PaymentSessionDetails
     */
    'browserColorDepth'?: number;
    /**
     * The screen height of the browser session (e.g., `1152`).
     * @type {number}
     * @memberof PaymentSessionDetails
     */
    'browserScreenHeight'?: number;
    /**
     * The screen width of the browser session (e.g., `2048`).
     * @type {number}
     * @memberof PaymentSessionDetails
     */
    'browserScreenWidth'?: number;
    /**
     * The timezone offset of the browser session (e.g., `-120`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    'browserTimezoneOffset'?: string;
}
/**
 * Shipping information associated with the payment.
 * @export
 * @interface PaymentShippingDetails
 */
export interface PaymentShippingDetails {
    /**
     * The shipping customer\'s full name.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    'name'?: string;
    /**
     * The shipping customer\'s email address.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    'email'?: string;
    /**
     * The shipping customer\'s phone number in E.164 format.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    'phone'?: string;
    /**
     * Name of the company where the shipment is going.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    'company'?: string;
    /**
     * Company tax ID.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    'taxId'?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentShippingDetails
     */
    'address'?: Address;
}
/**
 * The information about the shop (used in [hosted payment page](https://docs.monei.com/docs/use-prebuilt-payment-page)). 
 * @export
 * @interface PaymentShop
 */
export interface PaymentShop {
    /**
     * The shop name.
     * @type {string}
     * @memberof PaymentShop
     */
    'name'?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentShop
     */
    'country'?: string;
}
/**
 * The status of the payment.
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    SUCCEEDED: 'SUCCEEDED',
    PENDING: 'PENDING',
    FAILED: 'FAILED',
    CANCELED: 'CANCELED',
    REFUNDED: 'REFUNDED',
    PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED',
    AUTHORIZED: 'AUTHORIZED',
    EXPIRED: 'EXPIRED'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * Information related to the browsing session of the user who initiated the payment. 
 * @export
 * @interface PaymentTraceDetails
 */
export interface PaymentTraceDetails {
    /**
     * The IP address where the operation originated.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'ip'?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'countryCode'?: string;
    /**
     * Two-letter language code ([ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1)).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'lang'?: string;
    /**
     * Device type, could be `desktop`, `mobile`, `smartTV`, `tablet`.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'deviceType'?: string;
    /**
     * Information about the device used for the browser session (e.g., `iPhone`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'deviceModel'?: string;
    /**
     * The browser used in this browser session (e.g., `Mobile Safari`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'browser'?: string;
    /**
     * The version for the browser session (e.g., `13.1.1`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'browserVersion'?: string;
    /**
     * Operation system (e.g., `iOS`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'os'?: string;
    /**
     * Operation system version (e.g., `13.5.1`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'osVersion'?: string;
    /**
     * The source component from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'source'?: string;
    /**
     * The source component version from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'sourceVersion'?: string;
    /**
     * Full user agent string of the browser session.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'userAgent'?: string;
    /**
     * Browser accept header.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'browserAccept'?: string;
    /**
     * The color depth of the browser session (e.g., `24`).
     * @type {number}
     * @memberof PaymentTraceDetails
     */
    'browserColorDepth'?: number;
    /**
     * The screen height of the browser session (e.g., `1152`).
     * @type {number}
     * @memberof PaymentTraceDetails
     */
    'browserScreenHeight'?: number;
    /**
     * The screen width of the browser session (e.g., `2048`).
     * @type {number}
     * @memberof PaymentTraceDetails
     */
    'browserScreenWidth'?: number;
    /**
     * The timezone offset of the browser session (e.g., `-120`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'browserTimezoneOffset'?: string;
    /**
     * The ID of the user that started the operation.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'userId'?: string;
    /**
     * The email of the user that started the operation.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    'userEmail'?: string;
}
/**
 * Controls when the funds will be captured.   - `SALE` - **Default**. MONEI automatically captures funds     when the customer authorizes the payment.   - `AUTH` - Place a hold on the funds when the customer authorizes     the payment, but don\'t capture the funds until later.   - `PAYOUT` - Send funds to the customer   - `VERIF` - Verify the card without placing a hold or capturing funds. 
 * @export
 * @enum {string}
 */

export const PaymentTransactionType = {
    SALE: 'SALE',
    AUTH: 'AUTH',
    PAYOUT: 'PAYOUT',
    VERIF: 'VERIF'
} as const;

export type PaymentTransactionType = typeof PaymentTransactionType[keyof typeof PaymentTransactionType];


/**
 * 
 * @export
 * @interface RecurringPaymentRequest
 */
export interface RecurringPaymentRequest {
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system. 
     * @type {string}
     * @memberof RecurringPaymentRequest
     */
    'orderId': string;
    /**
     * The amount to collected by this subsequent payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof RecurringPaymentRequest
     */
    'amount'?: number;
    /**
     * Same as the `transactionType` parameter from [create payment](https://docs.monei.com/api/#operation/payments_create). If not sent, it will default in the same transaction type used in the initial payment. 
     * @type {PaymentTransactionType}
     * @memberof RecurringPaymentRequest
     */
    'transactionType'?: PaymentTransactionType;
    /**
     * An arbitrary string attached to the payment. Often useful for displaying to users. 
     * @type {string}
     * @memberof RecurringPaymentRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof RecurringPaymentRequest
     */
    'customer'?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof RecurringPaymentRequest
     */
    'billingDetails'?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof RecurringPaymentRequest
     */
    'shippingDetails'?: PaymentShippingDetails;
    /**
     * The URL to which a payment result should be sent asynchronously. 
     * @type {string}
     * @memberof RecurringPaymentRequest
     */
    'callbackUrl'?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof RecurringPaymentRequest
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @interface RefundPaymentRequest
 */
export interface RefundPaymentRequest {
    /**
     * The amount to refund, which must be less than or equal to the original amount. 
     * @type {number}
     * @memberof RefundPaymentRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {PaymentRefundReason}
     * @memberof RefundPaymentRequest
     */
    'refundReason'?: PaymentRefundReason;
}


/**
 * 
 * @export
 * @interface RegisterApplePayDomainRequest
 */
export interface RegisterApplePayDomainRequest {
    /**
     * The domain name to register for Apple Pay.
     * @type {string}
     * @memberof RegisterApplePayDomainRequest
     */
    'domainName': string;
}
/**
 * 
 * @export
 * @interface SendPaymentLinkRequest
 */
export interface SendPaymentLinkRequest {
    /**
     * The customer will receive payment link on this email address.
     * @type {string}
     * @memberof SendPaymentLinkRequest
     */
    'customerEmail'?: string;
    /**
     * Phone number in E.164 format. The customer will receive payment link on this phone number.
     * @type {string}
     * @memberof SendPaymentLinkRequest
     */
    'customerPhone'?: string;
    /**
     * 
     * @type {PaymentMessageChannel}
     * @memberof SendPaymentLinkRequest
     */
    'channel'?: PaymentMessageChannel;
    /**
     * 
     * @type {PaymentMessageLanguage}
     * @memberof SendPaymentLinkRequest
     */
    'language'?: PaymentMessageLanguage;
}


/**
 * 
 * @export
 * @interface SendPaymentReceiptRequest
 */
export interface SendPaymentReceiptRequest {
    /**
     * The customer will receive payment receipt on this email address.
     * @type {string}
     * @memberof SendPaymentReceiptRequest
     */
    'customerEmail'?: string;
    /**
     * Phone number in E.164 format. The customer will receive payment receipt link on this phone number.
     * @type {string}
     * @memberof SendPaymentReceiptRequest
     */
    'customerPhone'?: string;
    /**
     * 
     * @type {PaymentMessageChannel}
     * @memberof SendPaymentReceiptRequest
     */
    'channel'?: PaymentMessageChannel;
    /**
     * 
     * @type {PaymentMessageLanguage}
     * @memberof SendPaymentReceiptRequest
     */
    'language'?: PaymentMessageLanguage;
}


/**
 * 
 * @export
 * @interface SendPaymentRequestRequest
 */
export interface SendPaymentRequestRequest {
    /**
     * Phone number in E.164 format. The customer will receive payment link on this phone number.
     * @type {string}
     * @memberof SendPaymentRequestRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {PaymentMessageLanguage}
     * @memberof SendPaymentRequestRequest
     */
    'language'?: PaymentMessageLanguage;
}


/**
 * 
 * @export
 * @interface SendSubscriptionLinkRequest
 */
export interface SendSubscriptionLinkRequest {
    /**
     * Customer email to send the subscription link to
     * @type {string}
     * @memberof SendSubscriptionLinkRequest
     */
    'customerEmail'?: string;
    /**
     * Customer phone number to send the subscription link to
     * @type {string}
     * @memberof SendSubscriptionLinkRequest
     */
    'customerPhone'?: string;
    /**
     * Channel to use for sending the subscription link
     * @type {string}
     * @memberof SendSubscriptionLinkRequest
     */
    'channel'?: SendSubscriptionLinkRequestChannelEnum;
    /**
     * Language to use for the subscription link message
     * @type {string}
     * @memberof SendSubscriptionLinkRequest
     */
    'language'?: string;
}

export const SendSubscriptionLinkRequestChannelEnum = {
    EMAIL: 'EMAIL',
    WHATSAPP: 'WHATSAPP',
    SMS: 'SMS'
} as const;

export type SendSubscriptionLinkRequestChannelEnum = typeof SendSubscriptionLinkRequestChannelEnum[keyof typeof SendSubscriptionLinkRequestChannelEnum];

/**
 * 
 * @export
 * @interface SendSubscriptionStatusRequest
 */
export interface SendSubscriptionStatusRequest {
    /**
     * Customer email to send the subscription status to
     * @type {string}
     * @memberof SendSubscriptionStatusRequest
     */
    'customerEmail'?: string;
    /**
     * Customer phone number to send the subscription status to
     * @type {string}
     * @memberof SendSubscriptionStatusRequest
     */
    'customerPhone'?: string;
    /**
     * Channel to use for sending the subscription status
     * @type {string}
     * @memberof SendSubscriptionStatusRequest
     */
    'channel'?: SendSubscriptionStatusRequestChannelEnum;
    /**
     * Language to use for the subscription status message
     * @type {string}
     * @memberof SendSubscriptionStatusRequest
     */
    'language'?: string;
}

export const SendSubscriptionStatusRequestChannelEnum = {
    EMAIL: 'EMAIL',
    WHATSAPP: 'WHATSAPP',
    SMS: 'SMS'
} as const;

export type SendSubscriptionStatusRequestChannelEnum = typeof SendSubscriptionStatusRequestChannelEnum[keyof typeof SendSubscriptionStatusRequestChannelEnum];

/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * Unique identifier for the subscription.
     * @type {string}
     * @memberof Subscription
     */
    'id'?: string;
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof Subscription
     */
    'amount'?: number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency. 
     * @type {string}
     * @memberof Subscription
     */
    'currency'?: string;
    /**
     * An arbitrary string attached to the subscription. Often useful for displaying to users. 
     * @type {string}
     * @memberof Subscription
     */
    'description'?: string;
    /**
     * MONEI Account identifier.
     * @type {string}
     * @memberof Subscription
     */
    'accountId'?: string;
    /**
     * Has the value `true` if the resource exists in live mode or the value `false` if the resource exists in test mode.
     * @type {boolean}
     * @memberof Subscription
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {SubscriptionStatus}
     * @memberof Subscription
     */
    'status'?: SubscriptionStatus;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof Subscription
     */
    'customer'?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof Subscription
     */
    'billingDetails'?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof Subscription
     */
    'shippingDetails'?: PaymentShippingDetails;
    /**
     * 
     * @type {SubscriptionInterval}
     * @memberof Subscription
     */
    'interval'?: SubscriptionInterval;
    /**
     * Number of intervals between subscription payments.
     * @type {number}
     * @memberof Subscription
     */
    'intervalCount'?: number;
    /**
     * Number of intervals when subscription will be paused before it activates again.
     * @type {number}
     * @memberof Subscription
     */
    'pauseIntervalCount'?: number;
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system. 
     * @type {string}
     * @memberof Subscription
     */
    'lastOrderId'?: string;
    /**
     * 
     * @type {SubscriptionLastPayment}
     * @memberof Subscription
     */
    'lastPayment'?: SubscriptionLastPayment;
    /**
     * 
     * @type {SubscriptionPaymentMethod}
     * @memberof Subscription
     */
    'paymentMethod'?: SubscriptionPaymentMethod;
    /**
     * The start date of the current subscription period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    'currentPeriodStart'?: number;
    /**
     * The end date of the current subscription period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    'currentPeriodEnd'?: number;
    /**
     * The end date of the trial period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    'trialPeriodEnd'?: number;
    /**
     * The date when the next payment will be made.
     * @type {number}
     * @memberof Subscription
     */
    'nextPaymentAt'?: number;
    /**
     * Number of retries left for the subscription.
     * @type {number}
     * @memberof Subscription
     */
    'retryCount'?: number;
    /**
     * 
     * @type {SubscriptionRetrySchedule}
     * @memberof Subscription
     */
    'retrySchedule'?: SubscriptionRetrySchedule;
    /**
     * If true, the subscription will be canceled at the end of the current period. 
     * @type {boolean}
     * @memberof Subscription
     */
    'cancelAtPeriodEnd'?: boolean;
    /**
     * If true, the subscription will be paused at the end of the current period. 
     * @type {boolean}
     * @memberof Subscription
     */
    'pauseAtPeriodEnd'?: boolean;
    /**
     * 
     * @type {PaymentTraceDetails}
     * @memberof Subscription
     */
    'traceDetails'?: PaymentTraceDetails;
    /**
     * A permanent identifier that refers to the initial payment of a sequence of payments. This value needs to be sent in the path for `RECURRING` payments. 
     * @type {string}
     * @memberof Subscription
     */
    'sequenceId'?: string;
    /**
     * The URL will be called each time subscription status changes. You will receive a subscription object in the body of the request. 
     * @type {string}
     * @memberof Subscription
     */
    'callbackUrl'?: string;
    /**
     * The URL will be called each time subscription creates a new payments. You will receive the payment object in the body of the request. 
     * @type {string}
     * @memberof Subscription
     */
    'paymentCallbackUrl'?: string;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof Subscription
     */
    'metadata'?: object;
    /**
     * Time at which the resource was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    'createdAt'?: number;
    /**
     * Time at which the resource updated last time. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Subscription
     */
    'updatedAt'?: number;
}


/**
 * Subscription interval.
 * @export
 * @enum {string}
 */

export const SubscriptionInterval = {
    day: 'day',
    week: 'week',
    month: 'month',
    year: 'year'
} as const;

export type SubscriptionInterval = typeof SubscriptionInterval[keyof typeof SubscriptionInterval];


/**
 * 
 * @export
 * @interface SubscriptionLastPayment
 */
export interface SubscriptionLastPayment {
    /**
     * Unique identifier for the payment.
     * @type {string}
     * @memberof SubscriptionLastPayment
     */
    'id'?: string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof SubscriptionLastPayment
     */
    'status'?: PaymentStatus;
    /**
     * Payment status code. 
     * @type {string}
     * @memberof SubscriptionLastPayment
     */
    'statusCode'?: string;
    /**
     * Human readable status message, can be displayed to a user. 
     * @type {string}
     * @memberof SubscriptionLastPayment
     */
    'statusMessage'?: string;
}


/**
 * Details about the payment method at the time of the transaction. 
 * @export
 * @interface SubscriptionPaymentMethod
 */
export interface SubscriptionPaymentMethod {
    /**
     * Subscription method type.
     * @type {string}
     * @memberof SubscriptionPaymentMethod
     */
    'method'?: SubscriptionPaymentMethodMethodEnum;
    /**
     * 
     * @type {PaymentPaymentMethodCard}
     * @memberof SubscriptionPaymentMethod
     */
    'card'?: PaymentPaymentMethodCard;
}

export const SubscriptionPaymentMethodMethodEnum = {
    card: 'card'
} as const;

export type SubscriptionPaymentMethodMethodEnum = typeof SubscriptionPaymentMethodMethodEnum[keyof typeof SubscriptionPaymentMethodMethodEnum];

/**
 * Details about the card used as payment method at the time of the transaction. 
 * @export
 * @interface SubscriptionPaymentMethodCard
 */
export interface SubscriptionPaymentMethodCard {
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    'country'?: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    'brand'?: SubscriptionPaymentMethodCardBrandEnum;
    /**
     * Card type `debit` or `credit`.
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    'type'?: SubscriptionPaymentMethodCardTypeEnum;
    /**
     * Wether this transaction used 3D Secure authentication.
     * @type {boolean}
     * @memberof SubscriptionPaymentMethodCard
     */
    'threeDSecure'?: boolean;
    /**
     * The protocol version of the 3DS challenge.
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    'threeDSecureVersion'?: string;
    /**
     * Time at which the card will expire. Measured in seconds since the Unix epoch. 
     * @type {number}
     * @memberof SubscriptionPaymentMethodCard
     */
    'expiration'?: number;
    /**
     * The last four digits of the card.
     * @type {string}
     * @memberof SubscriptionPaymentMethodCard
     */
    'last4'?: string;
}

export const SubscriptionPaymentMethodCardBrandEnum = {
    visa: 'visa',
    mastercard: 'mastercard',
    diners: 'diners',
    amex: 'amex',
    jcb: 'jcb',
    unionpay: 'unionpay',
    unknown: 'unknown'
} as const;

export type SubscriptionPaymentMethodCardBrandEnum = typeof SubscriptionPaymentMethodCardBrandEnum[keyof typeof SubscriptionPaymentMethodCardBrandEnum];
export const SubscriptionPaymentMethodCardTypeEnum = {
    debit: 'debit',
    credit: 'credit'
} as const;

export type SubscriptionPaymentMethodCardTypeEnum = typeof SubscriptionPaymentMethodCardTypeEnum[keyof typeof SubscriptionPaymentMethodCardTypeEnum];

/**
 * Defines a custom schedule for retrying failed subscription payments. Each entry in the array specifies how long to wait before attempting the next payment retry. If not specified, the system\'s default retry schedule will be used. 
 * @export
 * @interface SubscriptionRetrySchedule
 */
export interface SubscriptionRetrySchedule extends Array<SubscriptionRetryScheduleInner> {
}
/**
 * 
 * @export
 * @interface SubscriptionRetryScheduleInner
 */
export interface SubscriptionRetryScheduleInner {
    /**
     * The unit of time to wait before the retry attempt.
     * @type {string}
     * @memberof SubscriptionRetryScheduleInner
     */
    'interval': SubscriptionRetryScheduleInnerIntervalEnum;
    /**
     * The number of intervals to wait before the retry attempt.
     * @type {number}
     * @memberof SubscriptionRetryScheduleInner
     */
    'intervalCount': number;
}

export const SubscriptionRetryScheduleInnerIntervalEnum = {
    day: 'day',
    week: 'week',
    month: 'month',
    year: 'year'
} as const;

export type SubscriptionRetryScheduleInnerIntervalEnum = typeof SubscriptionRetryScheduleInnerIntervalEnum[keyof typeof SubscriptionRetryScheduleInnerIntervalEnum];

/**
 * The status of the subscription.
 * @export
 * @enum {string}
 */

export const SubscriptionStatus = {
    PENDING: 'PENDING',
    EXPIRED: 'EXPIRED',
    TRIALING: 'TRIALING',
    ACTIVE: 'ACTIVE',
    PAST_DUE: 'PAST_DUE',
    PAUSED: 'PAUSED',
    CANCELED: 'CANCELED'
} as const;

export type SubscriptionStatus = typeof SubscriptionStatus[keyof typeof SubscriptionStatus];


/**
 * 
 * @export
 * @interface UpdateSubscriptionRequest
 */
export interface UpdateSubscriptionRequest {
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). 
     * @type {number}
     * @memberof UpdateSubscriptionRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {SubscriptionInterval}
     * @memberof UpdateSubscriptionRequest
     */
    'interval'?: SubscriptionInterval;
    /**
     * Number of intervals between subscription payments.
     * @type {number}
     * @memberof UpdateSubscriptionRequest
     */
    'intervalCount'?: number;
    /**
     * An arbitrary string attached to the subscription. Often useful for displaying to users. 
     * @type {string}
     * @memberof UpdateSubscriptionRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof UpdateSubscriptionRequest
     */
    'customer'?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof UpdateSubscriptionRequest
     */
    'billingDetails'?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof UpdateSubscriptionRequest
     */
    'shippingDetails'?: PaymentShippingDetails;
    /**
     * The end date of the trial period. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof UpdateSubscriptionRequest
     */
    'trialPeriodEnd'?: number;
    /**
     * The URL will be called each time subscription status changes. You will receive a subscription object in the body of the request. 
     * @type {string}
     * @memberof UpdateSubscriptionRequest
     */
    'callbackUrl'?: string;
    /**
     * The URL will be called each time subscription creates a new payments. You will receive the payment object in the body of the request. 
     * @type {string}
     * @memberof UpdateSubscriptionRequest
     */
    'paymentCallbackUrl'?: string;
    /**
     * If true, the subscription will be paused at the end of the current period. 
     * @type {boolean}
     * @memberof UpdateSubscriptionRequest
     */
    'pauseAtPeriodEnd'?: boolean;
    /**
     * If true, the subscription will be canceled at the end of the current period. 
     * @type {boolean}
     * @memberof UpdateSubscriptionRequest
     */
    'cancelAtPeriodEnd'?: boolean;
    /**
     * Number of intervals when subscription will be paused before it activates again.
     * @type {number}
     * @memberof UpdateSubscriptionRequest
     */
    'pauseIntervalCount'?: number;
    /**
     * 
     * @type {SubscriptionRetrySchedule}
     * @memberof UpdateSubscriptionRequest
     */
    'retrySchedule'?: SubscriptionRetrySchedule;
    /**
     * A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.
     * @type {object}
     * @memberof UpdateSubscriptionRequest
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @interface ValidateBizumPhoneRequest
 */
export interface ValidateBizumPhoneRequest {
    /**
     * MONEI Account identifier.
     * @type {string}
     * @memberof ValidateBizumPhoneRequest
     */
    'accountId': string;
    /**
     * Unique identifier for the payment.
     * @type {string}
     * @memberof ValidateBizumPhoneRequest
     */
    'paymentId'?: string;
    /**
     * Phone number in E.164 format.
     * @type {string}
     * @memberof ValidateBizumPhoneRequest
     */
    'phoneNumber': string;
}

/**
 * ApplePayDomainApi - axios parameter creator
 * @export
 */
export const ApplePayDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Registers a domain with Apple Pay.</p> <p>This endpoint allows you to register your website domain with Apple Pay, which is required before you can accept Apple Pay payments on your website. The domain must be accessible via HTTPS and have a valid SSL certificate.</p> <p>Before registering, you must download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you&#39;re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p> <p>After registration, Apple will verify your domain. Once verified, you can display Apple Pay buttons and process Apple Pay payments on your website.</p> 
         * @summary Register Domain
         * @param {RegisterApplePayDomainRequest} registerApplePayDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerApplePayDomainRequest: RegisterApplePayDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerApplePayDomainRequest' is not null or undefined
            assertParamExists('register', 'registerApplePayDomainRequest', registerApplePayDomainRequest)
            const localVarPath = `/apple-pay/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerApplePayDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplePayDomainApi - functional programming interface
 * @export
 */
export const ApplePayDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplePayDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Registers a domain with Apple Pay.</p> <p>This endpoint allows you to register your website domain with Apple Pay, which is required before you can accept Apple Pay payments on your website. The domain must be accessible via HTTPS and have a valid SSL certificate.</p> <p>Before registering, you must download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you&#39;re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p> <p>After registration, Apple will verify your domain. Once verified, you can display Apple Pay buttons and process Apple Pay payments on your website.</p> 
         * @summary Register Domain
         * @param {RegisterApplePayDomainRequest} registerApplePayDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerApplePayDomainRequest: RegisterApplePayDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplePayDomainRegister200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerApplePayDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplePayDomainApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplePayDomainApi - factory interface
 * @export
 */
export const ApplePayDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplePayDomainApiFp(configuration)
    return {
        /**
         * <p>Registers a domain with Apple Pay.</p> <p>This endpoint allows you to register your website domain with Apple Pay, which is required before you can accept Apple Pay payments on your website. The domain must be accessible via HTTPS and have a valid SSL certificate.</p> <p>Before registering, you must download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you&#39;re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p> <p>After registration, Apple will verify your domain. Once verified, you can display Apple Pay buttons and process Apple Pay payments on your website.</p> 
         * @summary Register Domain
         * @param {RegisterApplePayDomainRequest} registerApplePayDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerApplePayDomainRequest: RegisterApplePayDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplePayDomainRegister200Response> {
            return localVarFp.register(registerApplePayDomainRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplePayDomainApi - object-oriented interface
 * @export
 * @class ApplePayDomainApi
 * @extends {BaseAPI}
 */
export class ApplePayDomainApi extends BaseAPI {
    /**
     * <p>Registers a domain with Apple Pay.</p> <p>This endpoint allows you to register your website domain with Apple Pay, which is required before you can accept Apple Pay payments on your website. The domain must be accessible via HTTPS and have a valid SSL certificate.</p> <p>Before registering, you must download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you&#39;re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p> <p>After registration, Apple will verify your domain. Once verified, you can display Apple Pay buttons and process Apple Pay payments on your website.</p> 
     * @summary Register Domain
     * @param {RegisterApplePayDomainRequest} registerApplePayDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplePayDomainApi
     */
    public register(registerApplePayDomainRequest: RegisterApplePayDomainRequest, options?: RawAxiosRequestConfig) {
        return ApplePayDomainApiFp(this.configuration).register(registerApplePayDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BizumApi - axios parameter creator
 * @export
 */
export const BizumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Validates if a phone number is registered with Bizum.</p> <p>Use this endpoint to check if a customer&#39;s phone number can be used for Bizum payments before attempting to process a payment. This helps provide a better user experience by preventing failed payment attempts for non-registered numbers.</p> <p>The response will indicate whether the phone number is valid for Bizum payments.</p> 
         * @summary Validate Phone
         * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhone: async (validateBizumPhoneRequest: ValidateBizumPhoneRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateBizumPhoneRequest' is not null or undefined
            assertParamExists('validatePhone', 'validateBizumPhoneRequest', validateBizumPhoneRequest)
            const localVarPath = `/bizum/validate-phone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateBizumPhoneRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BizumApi - functional programming interface
 * @export
 */
export const BizumApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BizumApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Validates if a phone number is registered with Bizum.</p> <p>Use this endpoint to check if a customer&#39;s phone number can be used for Bizum payments before attempting to process a payment. This helps provide a better user experience by preventing failed payment attempts for non-registered numbers.</p> <p>The response will indicate whether the phone number is valid for Bizum payments.</p> 
         * @summary Validate Phone
         * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePhone(validateBizumPhoneRequest: ValidateBizumPhoneRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BizumValidatePhone200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatePhone(validateBizumPhoneRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BizumApi.validatePhone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BizumApi - factory interface
 * @export
 */
export const BizumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BizumApiFp(configuration)
    return {
        /**
         * <p>Validates if a phone number is registered with Bizum.</p> <p>Use this endpoint to check if a customer&#39;s phone number can be used for Bizum payments before attempting to process a payment. This helps provide a better user experience by preventing failed payment attempts for non-registered numbers.</p> <p>The response will indicate whether the phone number is valid for Bizum payments.</p> 
         * @summary Validate Phone
         * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhone(validateBizumPhoneRequest: ValidateBizumPhoneRequest, options?: RawAxiosRequestConfig): AxiosPromise<BizumValidatePhone200Response> {
            return localVarFp.validatePhone(validateBizumPhoneRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BizumApi - object-oriented interface
 * @export
 * @class BizumApi
 * @extends {BaseAPI}
 */
export class BizumApi extends BaseAPI {
    /**
     * <p>Validates if a phone number is registered with Bizum.</p> <p>Use this endpoint to check if a customer&#39;s phone number can be used for Bizum payments before attempting to process a payment. This helps provide a better user experience by preventing failed payment attempts for non-registered numbers.</p> <p>The response will indicate whether the phone number is valid for Bizum payments.</p> 
     * @summary Validate Phone
     * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BizumApi
     */
    public validatePhone(validateBizumPhoneRequest: ValidateBizumPhoneRequest, options?: RawAxiosRequestConfig) {
        return BizumApiFp(this.configuration).validatePhone(validateBizumPhoneRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentMethodsApi - axios parameter creator
 * @export
 */
export const PaymentMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Retrieve available payment methods for an account or a specific payment.</p> <p>You can provide either an <code>accountId</code> or a <code>paymentId</code> as a query parameter to get the available payment methods.</p> <p>When providing a <code>paymentId</code>, the response will include additional payment-specific information such as amount and currency. This is useful when you want to show payment options that are specifically available for a particular transaction.</p> <p>When providing an <code>accountId</code>, the response will include all payment methods available for that account based on the merchant&#39;s configuration and supported payment methods.</p> 
         * @summary Get Payment Methods
         * @param {string} [accountId] The ID of the account to get payment methods for
         * @param {string} [paymentId] The ID of the payment to get payment methods for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (accountId?: string, paymentId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (paymentId !== undefined) {
                localVarQueryParameter['paymentId'] = paymentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentMethodsApi - functional programming interface
 * @export
 */
export const PaymentMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Retrieve available payment methods for an account or a specific payment.</p> <p>You can provide either an <code>accountId</code> or a <code>paymentId</code> as a query parameter to get the available payment methods.</p> <p>When providing a <code>paymentId</code>, the response will include additional payment-specific information such as amount and currency. This is useful when you want to show payment options that are specifically available for a particular transaction.</p> <p>When providing an <code>accountId</code>, the response will include all payment methods available for that account based on the merchant&#39;s configuration and supported payment methods.</p> 
         * @summary Get Payment Methods
         * @param {string} [accountId] The ID of the account to get payment methods for
         * @param {string} [paymentId] The ID of the payment to get payment methods for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(accountId?: string, paymentId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethods>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(accountId, paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentMethodsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentMethodsApi - factory interface
 * @export
 */
export const PaymentMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentMethodsApiFp(configuration)
    return {
        /**
         * <p>Retrieve available payment methods for an account or a specific payment.</p> <p>You can provide either an <code>accountId</code> or a <code>paymentId</code> as a query parameter to get the available payment methods.</p> <p>When providing a <code>paymentId</code>, the response will include additional payment-specific information such as amount and currency. This is useful when you want to show payment options that are specifically available for a particular transaction.</p> <p>When providing an <code>accountId</code>, the response will include all payment methods available for that account based on the merchant&#39;s configuration and supported payment methods.</p> 
         * @summary Get Payment Methods
         * @param {string} [accountId] The ID of the account to get payment methods for
         * @param {string} [paymentId] The ID of the payment to get payment methods for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(accountId?: string, paymentId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethods> {
            return localVarFp.get(accountId, paymentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentMethodsApi - object-oriented interface
 * @export
 * @class PaymentMethodsApi
 * @extends {BaseAPI}
 */
export class PaymentMethodsApi extends BaseAPI {
    /**
     * <p>Retrieve available payment methods for an account or a specific payment.</p> <p>You can provide either an <code>accountId</code> or a <code>paymentId</code> as a query parameter to get the available payment methods.</p> <p>When providing a <code>paymentId</code>, the response will include additional payment-specific information such as amount and currency. This is useful when you want to show payment options that are specifically available for a particular transaction.</p> <p>When providing an <code>accountId</code>, the response will include all payment methods available for that account based on the merchant&#39;s configuration and supported payment methods.</p> 
     * @summary Get Payment Methods
     * @param {string} [accountId] The ID of the account to get payment methods for
     * @param {string} [paymentId] The ID of the payment to get payment methods for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    public get(accountId?: string, paymentId?: string, options?: RawAxiosRequestConfig) {
        return PaymentMethodsApiFp(this.configuration).get(accountId, paymentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Releases reserved funds from a previously authorized payment. This endpoint can only be used with payments in <code>AUTHORIZED</code> status.</p> <p>This operation is part of the two-step authorization flow:</p> <ol> <li><strong>Authorize</strong>: Create a payment with <code>transactionType: AUTH</code> to reserve funds</li> <li><strong>Cancel</strong>: Release the reserved funds if you decide not to capture the payment</li> </ol> <p>Cancellation makes the reserved funds available to the customer again and prevents you from being able to capture those funds in the future. Once cancelled, an authorization cannot be reactivated.</p> 
         * @summary Cancel Payment
         * @param {string} id The payment ID
         * @param {CancelPaymentRequest} [cancelPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, cancelPaymentRequest?: CancelPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/payments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Captures funds from a previously authorized payment. This endpoint can only be used with payments in <code>AUTHORIZED</code> status.</p> <p>This operation completes the two-step authorization flow:</p> <ol> <li><strong>Authorize</strong>: Create a payment with <code>transactionType: AUTH</code> to reserve funds</li> <li><strong>Capture</strong>: Transfer the reserved funds to your account when ready to fulfill the order</li> </ol> <p><strong>Important</strong>: Authorized payments expire after exactly seven days. After expiration, they will be marked as <code>EXPIRED</code> and can no longer be captured. Be sure to capture funds within this timeframe or communicate with your customer about a new payment.</p> 
         * @summary Capture Payment
         * @param {string} id The payment ID
         * @param {CapturePaymentRequest} [capturePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capture: async (id: string, capturePaymentRequest?: CapturePaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capture', 'id', id)
            const localVarPath = `/payments/{id}/capture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(capturePaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Confirms a payment that was created without payment details. This endpoint can only be used with payments in <code>PENDING</code> status.</p> <p>The two-step payment flow:</p> <ol> <li><strong>Create</strong>: First, create a payment without payment details (status: <code>PENDING</code>)</li> <li><strong>Confirm</strong>: Then provide payment details to complete the transaction</li> </ol> <p>When confirming a payment, you can use:</p> <ul> <li>A newly generated <code>paymentToken</code> from <a href=\"https://docs.monei.com/docs/monei-js-overview\">monei.js Components</a></li> <li>A permanent <code>paymentToken</code> from a previous payment (generated with <code>generatePaymentToken: true</code>)</li> </ul> <p>Using permanent payment tokens enables one-click checkout experiences for returning customers without requiring them to re-enter their payment information.</p> <p>You can provide additional customer information during confirmation, which will override any corresponding information originally passed in the payment creation request.</p> 
         * @summary Confirm Payment
         * @param {string} id The payment ID
         * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm: async (id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('confirm', 'id', id)
            const localVarPath = `/payments/{id}/confirm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Creates a new payment with the specified parameters.</p> <p>You can create a payment in two ways:</p> <ol> <li><strong>Immediate processing</strong>: Provide a <code>paymentToken</code> or <code>paymentMethod</code> - The payment will be processed instantly</li> <li><strong>Deferred processing</strong>: Create without payment details - The payment remains in <code>PENDING</code> status until you confirm it later using the <a href=\"#operation/payments_confirm\">confirm endpoint</a></li> </ol> <p>When creating a payment without payment details, you can redirect customers to the hosted payment page where they can select their preferred payment method and complete the transaction.</p> <p>For immediate processing, use one of these token options:</p> <ul> <li>A temporary <code>paymentToken</code> generated on the frontend using <a href=\"https://docs.monei.com/docs/monei-js-overview\">monei.js Components</a></li> <li>A permanent <code>paymentToken</code> from a previous successful payment (when <code>generatePaymentToken: true</code> was included)</li> </ul> <p>Permanent tokens enable one-click checkout experiences for returning customers by allowing you to securely store and reuse payment details without requiring customers to re-enter their information.</p> 
         * @summary Create Payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createPaymentRequest: CreatePaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentRequest' is not null or undefined
            assertParamExists('create', 'createPaymentRequest', createPaymentRequest)
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Retrieves the complete details of an existing payment by its unique ID.</p> <p>This endpoint returns all available information about the payment, including its current status, amount, customer details, timestamps, and transaction history. Use this to check the status of a payment, verify payment details, or retrieve information for your records.</p> <p>Supply the unique payment ID that was returned from your previous request.</p> 
         * @summary Get Payment
         * @param {string} id The payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('get', 'id', id)
            const localVarPath = `/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Creates a subsequent charge using the payment details from a previous transaction.</p> <p>This endpoint enables recurring billing and subscription payments by:</p> <ul> <li>Using the same payment method as the original payment</li> <li>Charging the customer without requiring them to re-enter payment details</li> <li>Supporting variable or fixed amounts (defaults to the original payment amount if not specified)</li> </ul> <p><strong>Prerequisites:</strong></p> <ol> <li>The initial payment must be created with the <code>sequence</code> parameter</li> <li>The initial payment will return a <code>sequenceId</code> in the response</li> <li>This <code>sequenceId</code> must be provided in the URL path when making subsequent recurring charges</li> </ol> <p>Ideal for subscription services, membership renewals, and installment payments.</p> <p><strong>Need more advanced subscription management?</strong> For comprehensive subscription management with features like billing cycles, trial periods, and automatic recurring billing, consider using the <a href=\"#tag/Subscriptions\">Subscriptions API</a> instead. It provides a complete solution for creating and managing subscription-based services.</p> 
         * @summary Recurring Payment
         * @param {string} sequenceId The sequence ID
         * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurring: async (sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            assertParamExists('recurring', 'sequenceId', sequenceId)
            const localVarPath = `/payments/{sequenceId}/recurring`
                .replace(`{${"sequenceId"}}`, encodeURIComponent(String(sequenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recurringPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Returns funds from a completed payment back to the customer&#39;s original payment method.</p> <p><strong>Refund options:</strong></p> <ul> <li><strong>Full refund</strong>: Return the entire payment amount</li> <li><strong>Partial refund</strong>: Specify an amount less than the original payment</li> <li><strong>Multiple partial refunds</strong>: Issue several partial refunds until the total payment amount is reached</li> </ul> <p><strong>Limitations:</strong></p> <ul> <li>You can only refund payments that have been successfully processed</li> <li>A payment can only be refunded up to its original amount</li> <li>Once fully refunded, a payment cannot be refunded again</li> <li>Attempting to refund more than the remaining available amount will result in an error</li> </ul> 
         * @summary Refund Payment
         * @param {string} id The payment ID
         * @param {RefundPaymentRequest} [refundPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refund: async (id: string, refundPaymentRequest?: RefundPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refund', 'id', id)
            const localVarPath = `/payments/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Sends a payment link to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for payments with the following status:</strong></p> <ul> <li>Pending</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Link is sent via email</li> <li>If customer phone is available: Link is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Link is sent via SMS as a fallback</li> </ul> <p>The payment link allows customers to complete the payment at their convenience using their preferred payment method on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the payment record.</p> 
         * @summary Send Payment Link
         * @param {string} id The payment ID
         * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLink: async (id: string, sendPaymentLinkRequest?: SendPaymentLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendLink', 'id', id)
            const localVarPath = `/payments/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendPaymentLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Sends a payment receipt to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for payments with the following status:</strong></p> <ul> <li>Succeeded</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Receipt is sent via email</li> <li>If customer phone is available: Receipt is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Receipt is sent via SMS as a fallback</li> </ul> <p>The receipt includes payment details such as amount, date, transaction ID, and merchant information, providing customers with a record of their successful transaction. If no customer contact information is provided, the system will use the details stored in the payment record.</p> 
         * @summary Send Payment Receipt
         * @param {string} id The payment ID
         * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReceipt: async (id: string, sendPaymentReceiptRequest?: SendPaymentReceiptRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendReceipt', 'id', id)
            const localVarPath = `/payments/{id}/receipt`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendPaymentReceiptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Sends a direct payment request to the customer&#39;s phone with smart channel selection.</p> <p><strong>Smart delivery logic based on customer phone capabilities:</strong></p> <ul> <li>If the phone number is registered with Bizum and that payment method is available: The customer receives a push notification in their banking app to instantly approve the payment</li> <li>If Bizum is not available or the phone is not registered with Bizum: The customer receives a payment link via WhatsApp to complete the payment</li> </ul> <p>This endpoint provides a streamlined payment experience, especially for Spanish customers with Bizum integration, enabling quick and convenient mobile payments.</p> 
         * @summary Send Payment Request
         * @param {string} id The payment ID
         * @param {SendPaymentRequestRequest} sendPaymentRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRequest: async (id: string, sendPaymentRequestRequest: SendPaymentRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendRequest', 'id', id)
            // verify required parameter 'sendPaymentRequestRequest' is not null or undefined
            assertParamExists('sendRequest', 'sendPaymentRequestRequest', sendPaymentRequestRequest)
            const localVarPath = `/payments/{id}/rtp`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendPaymentRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Releases reserved funds from a previously authorized payment. This endpoint can only be used with payments in <code>AUTHORIZED</code> status.</p> <p>This operation is part of the two-step authorization flow:</p> <ol> <li><strong>Authorize</strong>: Create a payment with <code>transactionType: AUTH</code> to reserve funds</li> <li><strong>Cancel</strong>: Release the reserved funds if you decide not to capture the payment</li> </ol> <p>Cancellation makes the reserved funds available to the customer again and prevents you from being able to capture those funds in the future. Once cancelled, an authorization cannot be reactivated.</p> 
         * @summary Cancel Payment
         * @param {string} id The payment ID
         * @param {CancelPaymentRequest} [cancelPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, cancelPaymentRequest?: CancelPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, cancelPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Captures funds from a previously authorized payment. This endpoint can only be used with payments in <code>AUTHORIZED</code> status.</p> <p>This operation completes the two-step authorization flow:</p> <ol> <li><strong>Authorize</strong>: Create a payment with <code>transactionType: AUTH</code> to reserve funds</li> <li><strong>Capture</strong>: Transfer the reserved funds to your account when ready to fulfill the order</li> </ol> <p><strong>Important</strong>: Authorized payments expire after exactly seven days. After expiration, they will be marked as <code>EXPIRED</code> and can no longer be captured. Be sure to capture funds within this timeframe or communicate with your customer about a new payment.</p> 
         * @summary Capture Payment
         * @param {string} id The payment ID
         * @param {CapturePaymentRequest} [capturePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capture(id: string, capturePaymentRequest?: CapturePaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capture(id, capturePaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.capture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Confirms a payment that was created without payment details. This endpoint can only be used with payments in <code>PENDING</code> status.</p> <p>The two-step payment flow:</p> <ol> <li><strong>Create</strong>: First, create a payment without payment details (status: <code>PENDING</code>)</li> <li><strong>Confirm</strong>: Then provide payment details to complete the transaction</li> </ol> <p>When confirming a payment, you can use:</p> <ul> <li>A newly generated <code>paymentToken</code> from <a href=\"https://docs.monei.com/docs/monei-js-overview\">monei.js Components</a></li> <li>A permanent <code>paymentToken</code> from a previous payment (generated with <code>generatePaymentToken: true</code>)</li> </ul> <p>Using permanent payment tokens enables one-click checkout experiences for returning customers without requiring them to re-enter their payment information.</p> <p>You can provide additional customer information during confirmation, which will override any corresponding information originally passed in the payment creation request.</p> 
         * @summary Confirm Payment
         * @param {string} id The payment ID
         * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirm(id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirm(id, confirmPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.confirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Creates a new payment with the specified parameters.</p> <p>You can create a payment in two ways:</p> <ol> <li><strong>Immediate processing</strong>: Provide a <code>paymentToken</code> or <code>paymentMethod</code> - The payment will be processed instantly</li> <li><strong>Deferred processing</strong>: Create without payment details - The payment remains in <code>PENDING</code> status until you confirm it later using the <a href=\"#operation/payments_confirm\">confirm endpoint</a></li> </ol> <p>When creating a payment without payment details, you can redirect customers to the hosted payment page where they can select their preferred payment method and complete the transaction.</p> <p>For immediate processing, use one of these token options:</p> <ul> <li>A temporary <code>paymentToken</code> generated on the frontend using <a href=\"https://docs.monei.com/docs/monei-js-overview\">monei.js Components</a></li> <li>A permanent <code>paymentToken</code> from a previous successful payment (when <code>generatePaymentToken: true</code> was included)</li> </ul> <p>Permanent tokens enable one-click checkout experiences for returning customers by allowing you to securely store and reuse payment details without requiring customers to re-enter their information.</p> 
         * @summary Create Payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createPaymentRequest: CreatePaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Retrieves the complete details of an existing payment by its unique ID.</p> <p>This endpoint returns all available information about the payment, including its current status, amount, customer details, timestamps, and transaction history. Use this to check the status of a payment, verify payment details, or retrieve information for your records.</p> <p>Supply the unique payment ID that was returned from your previous request.</p> 
         * @summary Get Payment
         * @param {string} id The payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Creates a subsequent charge using the payment details from a previous transaction.</p> <p>This endpoint enables recurring billing and subscription payments by:</p> <ul> <li>Using the same payment method as the original payment</li> <li>Charging the customer without requiring them to re-enter payment details</li> <li>Supporting variable or fixed amounts (defaults to the original payment amount if not specified)</li> </ul> <p><strong>Prerequisites:</strong></p> <ol> <li>The initial payment must be created with the <code>sequence</code> parameter</li> <li>The initial payment will return a <code>sequenceId</code> in the response</li> <li>This <code>sequenceId</code> must be provided in the URL path when making subsequent recurring charges</li> </ol> <p>Ideal for subscription services, membership renewals, and installment payments.</p> <p><strong>Need more advanced subscription management?</strong> For comprehensive subscription management with features like billing cycles, trial periods, and automatic recurring billing, consider using the <a href=\"#tag/Subscriptions\">Subscriptions API</a> instead. It provides a complete solution for creating and managing subscription-based services.</p> 
         * @summary Recurring Payment
         * @param {string} sequenceId The sequence ID
         * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recurring(sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recurring(sequenceId, recurringPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.recurring']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Returns funds from a completed payment back to the customer&#39;s original payment method.</p> <p><strong>Refund options:</strong></p> <ul> <li><strong>Full refund</strong>: Return the entire payment amount</li> <li><strong>Partial refund</strong>: Specify an amount less than the original payment</li> <li><strong>Multiple partial refunds</strong>: Issue several partial refunds until the total payment amount is reached</li> </ul> <p><strong>Limitations:</strong></p> <ul> <li>You can only refund payments that have been successfully processed</li> <li>A payment can only be refunded up to its original amount</li> <li>Once fully refunded, a payment cannot be refunded again</li> <li>Attempting to refund more than the remaining available amount will result in an error</li> </ul> 
         * @summary Refund Payment
         * @param {string} id The payment ID
         * @param {RefundPaymentRequest} [refundPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refund(id: string, refundPaymentRequest?: RefundPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refund(id, refundPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.refund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Sends a payment link to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for payments with the following status:</strong></p> <ul> <li>Pending</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Link is sent via email</li> <li>If customer phone is available: Link is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Link is sent via SMS as a fallback</li> </ul> <p>The payment link allows customers to complete the payment at their convenience using their preferred payment method on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the payment record.</p> 
         * @summary Send Payment Link
         * @param {string} id The payment ID
         * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLink(id: string, sendPaymentLinkRequest?: SendPaymentLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLink(id, sendPaymentLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.sendLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Sends a payment receipt to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for payments with the following status:</strong></p> <ul> <li>Succeeded</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Receipt is sent via email</li> <li>If customer phone is available: Receipt is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Receipt is sent via SMS as a fallback</li> </ul> <p>The receipt includes payment details such as amount, date, transaction ID, and merchant information, providing customers with a record of their successful transaction. If no customer contact information is provided, the system will use the details stored in the payment record.</p> 
         * @summary Send Payment Receipt
         * @param {string} id The payment ID
         * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendReceipt(id: string, sendPaymentReceiptRequest?: SendPaymentReceiptRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendReceipt(id, sendPaymentReceiptRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.sendReceipt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Sends a direct payment request to the customer&#39;s phone with smart channel selection.</p> <p><strong>Smart delivery logic based on customer phone capabilities:</strong></p> <ul> <li>If the phone number is registered with Bizum and that payment method is available: The customer receives a push notification in their banking app to instantly approve the payment</li> <li>If Bizum is not available or the phone is not registered with Bizum: The customer receives a payment link via WhatsApp to complete the payment</li> </ul> <p>This endpoint provides a streamlined payment experience, especially for Spanish customers with Bizum integration, enabling quick and convenient mobile payments.</p> 
         * @summary Send Payment Request
         * @param {string} id The payment ID
         * @param {SendPaymentRequestRequest} sendPaymentRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRequest(id: string, sendPaymentRequestRequest: SendPaymentRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRequest(id, sendPaymentRequestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.sendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * <p>Releases reserved funds from a previously authorized payment. This endpoint can only be used with payments in <code>AUTHORIZED</code> status.</p> <p>This operation is part of the two-step authorization flow:</p> <ol> <li><strong>Authorize</strong>: Create a payment with <code>transactionType: AUTH</code> to reserve funds</li> <li><strong>Cancel</strong>: Release the reserved funds if you decide not to capture the payment</li> </ol> <p>Cancellation makes the reserved funds available to the customer again and prevents you from being able to capture those funds in the future. Once cancelled, an authorization cannot be reactivated.</p> 
         * @summary Cancel Payment
         * @param {string} id The payment ID
         * @param {CancelPaymentRequest} [cancelPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, cancelPaymentRequest?: CancelPaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.cancel(id, cancelPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Captures funds from a previously authorized payment. This endpoint can only be used with payments in <code>AUTHORIZED</code> status.</p> <p>This operation completes the two-step authorization flow:</p> <ol> <li><strong>Authorize</strong>: Create a payment with <code>transactionType: AUTH</code> to reserve funds</li> <li><strong>Capture</strong>: Transfer the reserved funds to your account when ready to fulfill the order</li> </ol> <p><strong>Important</strong>: Authorized payments expire after exactly seven days. After expiration, they will be marked as <code>EXPIRED</code> and can no longer be captured. Be sure to capture funds within this timeframe or communicate with your customer about a new payment.</p> 
         * @summary Capture Payment
         * @param {string} id The payment ID
         * @param {CapturePaymentRequest} [capturePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capture(id: string, capturePaymentRequest?: CapturePaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.capture(id, capturePaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Confirms a payment that was created without payment details. This endpoint can only be used with payments in <code>PENDING</code> status.</p> <p>The two-step payment flow:</p> <ol> <li><strong>Create</strong>: First, create a payment without payment details (status: <code>PENDING</code>)</li> <li><strong>Confirm</strong>: Then provide payment details to complete the transaction</li> </ol> <p>When confirming a payment, you can use:</p> <ul> <li>A newly generated <code>paymentToken</code> from <a href=\"https://docs.monei.com/docs/monei-js-overview\">monei.js Components</a></li> <li>A permanent <code>paymentToken</code> from a previous payment (generated with <code>generatePaymentToken: true</code>)</li> </ul> <p>Using permanent payment tokens enables one-click checkout experiences for returning customers without requiring them to re-enter their payment information.</p> <p>You can provide additional customer information during confirmation, which will override any corresponding information originally passed in the payment creation request.</p> 
         * @summary Confirm Payment
         * @param {string} id The payment ID
         * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm(id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.confirm(id, confirmPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Creates a new payment with the specified parameters.</p> <p>You can create a payment in two ways:</p> <ol> <li><strong>Immediate processing</strong>: Provide a <code>paymentToken</code> or <code>paymentMethod</code> - The payment will be processed instantly</li> <li><strong>Deferred processing</strong>: Create without payment details - The payment remains in <code>PENDING</code> status until you confirm it later using the <a href=\"#operation/payments_confirm\">confirm endpoint</a></li> </ol> <p>When creating a payment without payment details, you can redirect customers to the hosted payment page where they can select their preferred payment method and complete the transaction.</p> <p>For immediate processing, use one of these token options:</p> <ul> <li>A temporary <code>paymentToken</code> generated on the frontend using <a href=\"https://docs.monei.com/docs/monei-js-overview\">monei.js Components</a></li> <li>A permanent <code>paymentToken</code> from a previous successful payment (when <code>generatePaymentToken: true</code> was included)</li> </ul> <p>Permanent tokens enable one-click checkout experiences for returning customers by allowing you to securely store and reuse payment details without requiring customers to re-enter their information.</p> 
         * @summary Create Payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createPaymentRequest: CreatePaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.create(createPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Retrieves the complete details of an existing payment by its unique ID.</p> <p>This endpoint returns all available information about the payment, including its current status, amount, customer details, timestamps, and transaction history. Use this to check the status of a payment, verify payment details, or retrieve information for your records.</p> <p>Supply the unique payment ID that was returned from your previous request.</p> 
         * @summary Get Payment
         * @param {string} id The payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.get(id, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Creates a subsequent charge using the payment details from a previous transaction.</p> <p>This endpoint enables recurring billing and subscription payments by:</p> <ul> <li>Using the same payment method as the original payment</li> <li>Charging the customer without requiring them to re-enter payment details</li> <li>Supporting variable or fixed amounts (defaults to the original payment amount if not specified)</li> </ul> <p><strong>Prerequisites:</strong></p> <ol> <li>The initial payment must be created with the <code>sequence</code> parameter</li> <li>The initial payment will return a <code>sequenceId</code> in the response</li> <li>This <code>sequenceId</code> must be provided in the URL path when making subsequent recurring charges</li> </ol> <p>Ideal for subscription services, membership renewals, and installment payments.</p> <p><strong>Need more advanced subscription management?</strong> For comprehensive subscription management with features like billing cycles, trial periods, and automatic recurring billing, consider using the <a href=\"#tag/Subscriptions\">Subscriptions API</a> instead. It provides a complete solution for creating and managing subscription-based services.</p> 
         * @summary Recurring Payment
         * @param {string} sequenceId The sequence ID
         * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurring(sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.recurring(sequenceId, recurringPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Returns funds from a completed payment back to the customer&#39;s original payment method.</p> <p><strong>Refund options:</strong></p> <ul> <li><strong>Full refund</strong>: Return the entire payment amount</li> <li><strong>Partial refund</strong>: Specify an amount less than the original payment</li> <li><strong>Multiple partial refunds</strong>: Issue several partial refunds until the total payment amount is reached</li> </ul> <p><strong>Limitations:</strong></p> <ul> <li>You can only refund payments that have been successfully processed</li> <li>A payment can only be refunded up to its original amount</li> <li>Once fully refunded, a payment cannot be refunded again</li> <li>Attempting to refund more than the remaining available amount will result in an error</li> </ul> 
         * @summary Refund Payment
         * @param {string} id The payment ID
         * @param {RefundPaymentRequest} [refundPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refund(id: string, refundPaymentRequest?: RefundPaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.refund(id, refundPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Sends a payment link to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for payments with the following status:</strong></p> <ul> <li>Pending</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Link is sent via email</li> <li>If customer phone is available: Link is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Link is sent via SMS as a fallback</li> </ul> <p>The payment link allows customers to complete the payment at their convenience using their preferred payment method on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the payment record.</p> 
         * @summary Send Payment Link
         * @param {string} id The payment ID
         * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLink(id: string, sendPaymentLinkRequest?: SendPaymentLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.sendLink(id, sendPaymentLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Sends a payment receipt to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for payments with the following status:</strong></p> <ul> <li>Succeeded</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Receipt is sent via email</li> <li>If customer phone is available: Receipt is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Receipt is sent via SMS as a fallback</li> </ul> <p>The receipt includes payment details such as amount, date, transaction ID, and merchant information, providing customers with a record of their successful transaction. If no customer contact information is provided, the system will use the details stored in the payment record.</p> 
         * @summary Send Payment Receipt
         * @param {string} id The payment ID
         * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReceipt(id: string, sendPaymentReceiptRequest?: SendPaymentReceiptRequest, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.sendReceipt(id, sendPaymentReceiptRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Sends a direct payment request to the customer&#39;s phone with smart channel selection.</p> <p><strong>Smart delivery logic based on customer phone capabilities:</strong></p> <ul> <li>If the phone number is registered with Bizum and that payment method is available: The customer receives a push notification in their banking app to instantly approve the payment</li> <li>If Bizum is not available or the phone is not registered with Bizum: The customer receives a payment link via WhatsApp to complete the payment</li> </ul> <p>This endpoint provides a streamlined payment experience, especially for Spanish customers with Bizum integration, enabling quick and convenient mobile payments.</p> 
         * @summary Send Payment Request
         * @param {string} id The payment ID
         * @param {SendPaymentRequestRequest} sendPaymentRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRequest(id: string, sendPaymentRequestRequest: SendPaymentRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.sendRequest(id, sendPaymentRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * <p>Releases reserved funds from a previously authorized payment. This endpoint can only be used with payments in <code>AUTHORIZED</code> status.</p> <p>This operation is part of the two-step authorization flow:</p> <ol> <li><strong>Authorize</strong>: Create a payment with <code>transactionType: AUTH</code> to reserve funds</li> <li><strong>Cancel</strong>: Release the reserved funds if you decide not to capture the payment</li> </ol> <p>Cancellation makes the reserved funds available to the customer again and prevents you from being able to capture those funds in the future. Once cancelled, an authorization cannot be reactivated.</p> 
     * @summary Cancel Payment
     * @param {string} id The payment ID
     * @param {CancelPaymentRequest} [cancelPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public cancel(id: string, cancelPaymentRequest?: CancelPaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).cancel(id, cancelPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Captures funds from a previously authorized payment. This endpoint can only be used with payments in <code>AUTHORIZED</code> status.</p> <p>This operation completes the two-step authorization flow:</p> <ol> <li><strong>Authorize</strong>: Create a payment with <code>transactionType: AUTH</code> to reserve funds</li> <li><strong>Capture</strong>: Transfer the reserved funds to your account when ready to fulfill the order</li> </ol> <p><strong>Important</strong>: Authorized payments expire after exactly seven days. After expiration, they will be marked as <code>EXPIRED</code> and can no longer be captured. Be sure to capture funds within this timeframe or communicate with your customer about a new payment.</p> 
     * @summary Capture Payment
     * @param {string} id The payment ID
     * @param {CapturePaymentRequest} [capturePaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public capture(id: string, capturePaymentRequest?: CapturePaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).capture(id, capturePaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Confirms a payment that was created without payment details. This endpoint can only be used with payments in <code>PENDING</code> status.</p> <p>The two-step payment flow:</p> <ol> <li><strong>Create</strong>: First, create a payment without payment details (status: <code>PENDING</code>)</li> <li><strong>Confirm</strong>: Then provide payment details to complete the transaction</li> </ol> <p>When confirming a payment, you can use:</p> <ul> <li>A newly generated <code>paymentToken</code> from <a href=\"https://docs.monei.com/docs/monei-js-overview\">monei.js Components</a></li> <li>A permanent <code>paymentToken</code> from a previous payment (generated with <code>generatePaymentToken: true</code>)</li> </ul> <p>Using permanent payment tokens enables one-click checkout experiences for returning customers without requiring them to re-enter their payment information.</p> <p>You can provide additional customer information during confirmation, which will override any corresponding information originally passed in the payment creation request.</p> 
     * @summary Confirm Payment
     * @param {string} id The payment ID
     * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public confirm(id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).confirm(id, confirmPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Creates a new payment with the specified parameters.</p> <p>You can create a payment in two ways:</p> <ol> <li><strong>Immediate processing</strong>: Provide a <code>paymentToken</code> or <code>paymentMethod</code> - The payment will be processed instantly</li> <li><strong>Deferred processing</strong>: Create without payment details - The payment remains in <code>PENDING</code> status until you confirm it later using the <a href=\"#operation/payments_confirm\">confirm endpoint</a></li> </ol> <p>When creating a payment without payment details, you can redirect customers to the hosted payment page where they can select their preferred payment method and complete the transaction.</p> <p>For immediate processing, use one of these token options:</p> <ul> <li>A temporary <code>paymentToken</code> generated on the frontend using <a href=\"https://docs.monei.com/docs/monei-js-overview\">monei.js Components</a></li> <li>A permanent <code>paymentToken</code> from a previous successful payment (when <code>generatePaymentToken: true</code> was included)</li> </ul> <p>Permanent tokens enable one-click checkout experiences for returning customers by allowing you to securely store and reuse payment details without requiring customers to re-enter their information.</p> 
     * @summary Create Payment
     * @param {CreatePaymentRequest} createPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public create(createPaymentRequest: CreatePaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).create(createPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Retrieves the complete details of an existing payment by its unique ID.</p> <p>This endpoint returns all available information about the payment, including its current status, amount, customer details, timestamps, and transaction history. Use this to check the status of a payment, verify payment details, or retrieve information for your records.</p> <p>Supply the unique payment ID that was returned from your previous request.</p> 
     * @summary Get Payment
     * @param {string} id The payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public get(id: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).get(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Creates a subsequent charge using the payment details from a previous transaction.</p> <p>This endpoint enables recurring billing and subscription payments by:</p> <ul> <li>Using the same payment method as the original payment</li> <li>Charging the customer without requiring them to re-enter payment details</li> <li>Supporting variable or fixed amounts (defaults to the original payment amount if not specified)</li> </ul> <p><strong>Prerequisites:</strong></p> <ol> <li>The initial payment must be created with the <code>sequence</code> parameter</li> <li>The initial payment will return a <code>sequenceId</code> in the response</li> <li>This <code>sequenceId</code> must be provided in the URL path when making subsequent recurring charges</li> </ol> <p>Ideal for subscription services, membership renewals, and installment payments.</p> <p><strong>Need more advanced subscription management?</strong> For comprehensive subscription management with features like billing cycles, trial periods, and automatic recurring billing, consider using the <a href=\"#tag/Subscriptions\">Subscriptions API</a> instead. It provides a complete solution for creating and managing subscription-based services.</p> 
     * @summary Recurring Payment
     * @param {string} sequenceId The sequence ID
     * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public recurring(sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).recurring(sequenceId, recurringPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Returns funds from a completed payment back to the customer&#39;s original payment method.</p> <p><strong>Refund options:</strong></p> <ul> <li><strong>Full refund</strong>: Return the entire payment amount</li> <li><strong>Partial refund</strong>: Specify an amount less than the original payment</li> <li><strong>Multiple partial refunds</strong>: Issue several partial refunds until the total payment amount is reached</li> </ul> <p><strong>Limitations:</strong></p> <ul> <li>You can only refund payments that have been successfully processed</li> <li>A payment can only be refunded up to its original amount</li> <li>Once fully refunded, a payment cannot be refunded again</li> <li>Attempting to refund more than the remaining available amount will result in an error</li> </ul> 
     * @summary Refund Payment
     * @param {string} id The payment ID
     * @param {RefundPaymentRequest} [refundPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public refund(id: string, refundPaymentRequest?: RefundPaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).refund(id, refundPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Sends a payment link to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for payments with the following status:</strong></p> <ul> <li>Pending</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Link is sent via email</li> <li>If customer phone is available: Link is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Link is sent via SMS as a fallback</li> </ul> <p>The payment link allows customers to complete the payment at their convenience using their preferred payment method on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the payment record.</p> 
     * @summary Send Payment Link
     * @param {string} id The payment ID
     * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public sendLink(id: string, sendPaymentLinkRequest?: SendPaymentLinkRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).sendLink(id, sendPaymentLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Sends a payment receipt to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for payments with the following status:</strong></p> <ul> <li>Succeeded</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Receipt is sent via email</li> <li>If customer phone is available: Receipt is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Receipt is sent via SMS as a fallback</li> </ul> <p>The receipt includes payment details such as amount, date, transaction ID, and merchant information, providing customers with a record of their successful transaction. If no customer contact information is provided, the system will use the details stored in the payment record.</p> 
     * @summary Send Payment Receipt
     * @param {string} id The payment ID
     * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public sendReceipt(id: string, sendPaymentReceiptRequest?: SendPaymentReceiptRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).sendReceipt(id, sendPaymentReceiptRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Sends a direct payment request to the customer&#39;s phone with smart channel selection.</p> <p><strong>Smart delivery logic based on customer phone capabilities:</strong></p> <ul> <li>If the phone number is registered with Bizum and that payment method is available: The customer receives a push notification in their banking app to instantly approve the payment</li> <li>If Bizum is not available or the phone is not registered with Bizum: The customer receives a payment link via WhatsApp to complete the payment</li> </ul> <p>This endpoint provides a streamlined payment experience, especially for Spanish customers with Bizum integration, enabling quick and convenient mobile payments.</p> 
     * @summary Send Payment Request
     * @param {string} id The payment ID
     * @param {SendPaymentRequestRequest} sendPaymentRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public sendRequest(id: string, sendPaymentRequestRequest: SendPaymentRequestRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).sendRequest(id, sendPaymentRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Activates a subscription by attaching a payment method and initiating the billing cycle.</p> <p><strong>Activation Process</strong>:</p> <ol> <li>This endpoint transitions a <code>PENDING</code> subscription to <code>ACTIVE</code> status</li> <li>An initial payment is created to validate the payment method:<ul> <li>For regular subscriptions: First billing cycle payment is processed immediately</li> <li>For trial subscriptions: A zero-amount payment is created to verify the payment method</li> </ul> </li> </ol> <p><strong>Payment Method Updates</strong>: If the subscription is already active, this endpoint can be used to update the payment method. The update process creates a zero-amount payment to verify the new payment method works correctly.</p> <p><strong>Important Notes</strong>:</p> <ul> <li>Subscription billing begins immediately upon successful activation (unless in trial period)</li> <li>The payment method provided will be used for all future recurring charges</li> <li>Activation failures (due to invalid payment method) will keep the subscription in <code>PENDING</code> status</li> </ul> 
         * @summary Activate Subscription
         * @param {string} id The subscription ID
         * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate: async (id: string, activateSubscriptionRequest?: ActivateSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('activate', 'id', id)
            const localVarPath = `/subscriptions/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Cancels an active subscription, permanently stopping the billing cycle.</p> <p><strong>Cancellation Effects</strong>:</p> <ul> <li>The subscription status changes to <code>CANCELED</code></li> <li>No further charges will be processed</li> <li>Access to subscription services typically ends immediately or at period end (depending on your business rules)</li> </ul> <p><strong>Important Notes</strong>:</p> <ul> <li>Cancellation is permanent and cannot be undone</li> <li>To restart service, a new subscription must be created</li> <li>Consider using <code>pauseAtPeriodEnd</code> or <code>cancelAtPeriodEnd</code> for softer transitions</li> </ul> <p>Use this endpoint when a customer wishes to completely terminate their subscription.</p> 
         * @summary Cancel Subscription
         * @param {string} id The subscription ID
         * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, cancelSubscriptionRequest?: CancelSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/subscriptions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Creates a new subscription with the specified parameters.</p> <p><strong>Subscription Lifecycle</strong>:</p> <ol> <li>When first created, the subscription has a <code>PENDING</code> status</li> <li>To initiate billing, you must call the <a href=\"#operation/subscriptions_activate\">activate endpoint</a> with payment details</li> <li>Once activated, the subscription will automatically bill according to the configured interval</li> </ol> <p><strong>Key Configuration Parameters</strong>:</p> <ul> <li><strong>Billing settings</strong>: Amount, currency, interval (daily, weekly, monthly, yearly)</li> <li><strong>Schedule customization</strong>: Interval count, trial period duration</li> <li><strong>Customer information</strong>: Contact details, billing and shipping addresses</li> <li><strong>Communication</strong>: Callback URLs for webhook notifications about subscription events</li> </ul> <p><strong>Best Practices</strong>:</p> <ul> <li>Set clear, descriptive names for subscriptions to help with identification</li> <li>Configure appropriate webhook notifications to monitor subscription status changes</li> <li>Consider offering trial periods to increase customer conversion rates</li> <li>Use metadata to store additional information relevant to your business logic</li> </ul> 
         * @summary Create Subscription
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createSubscriptionRequest: CreateSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSubscriptionRequest' is not null or undefined
            assertParamExists('create', 'createSubscriptionRequest', createSubscriptionRequest)
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Retrieves the complete details of an existing subscription by its unique ID.</p> <p>This endpoint returns comprehensive information about the subscription, including:</p> <ul> <li>Current status and lifecycle details (active, paused, canceled)</li> <li>Billing configuration (amount, currency, interval)</li> <li>Schedule information (current period, next payment date)</li> <li>Customer and payment method details</li> <li>Payment history (including last payment status)</li> <li>Trial period information (if applicable)</li> </ul> <p>Use this endpoint to check subscription status, verify billing details, or retrieve information needed for customer support inquiries.</p> 
         * @summary Get Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('get', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Pauses an active subscription, temporarily halting the billing cycle.</p> <p><strong>Pause Effects</strong>:</p> <ul> <li>Billing is immediately suspended</li> <li>The subscription status changes to <code>PAUSED</code></li> <li>No charges will be processed while the subscription remains paused</li> <li>The current billing period end date remains unchanged</li> </ul> <p><strong>Use Cases</strong>:</p> <ul> <li>Temporary service interruptions</li> <li>Customer vacation or absence periods</li> <li>Account maintenance or dispute resolution</li> </ul> <p>To resume billing, use the <a href=\"#operation/subscriptions_resume\">resume endpoint</a>.</p> 
         * @summary Pause Subscription
         * @param {string} id The subscription ID
         * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause: async (id: string, pauseSubscriptionRequest?: PauseSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pause', 'id', id)
            const localVarPath = `/subscriptions/{id}/pause`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pauseSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Resumes a previously paused subscription, reactivating the billing cycle.</p> <p><strong>Resume Effects</strong>:</p> <ul> <li>Billing is immediately reactivated</li> <li>The subscription status changes from <code>PAUSED</code> to <code>ACTIVE</code></li> <li>The next billing date is recalculated based on the current date</li> <li>Regular charging schedule resumes according to the subscription interval</li> </ul> <p><strong>Important Notes</strong>:</p> <ul> <li>No immediate charge is created when resuming (billing continues on next scheduled date)</li> <li>Any pause duration is added to the current billing period, maintaining the expected number of billing cycles</li> <li>If a significant time has passed, verify that the payment method is still valid</li> </ul> 
         * @summary Resume Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resume', 'id', id)
            const localVarPath = `/subscriptions/{id}/resume`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Sends a subscription activation link to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for subscriptions with the following status:</strong></p> <ul> <li>Pending</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Link is sent via email</li> <li>If customer phone is available: Link is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Link is sent via SMS as a fallback</li> </ul> <p>The subscription activation link allows customers to complete their subscription setup by providing payment details on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the subscription record.</p> 
         * @summary Send Subscription Link
         * @param {string} id The subscription ID
         * @param {SendSubscriptionLinkRequest} [sendSubscriptionLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLink: async (id: string, sendSubscriptionLinkRequest?: SendSubscriptionLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendLink', 'id', id)
            const localVarPath = `/subscriptions/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendSubscriptionLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Sends subscription status information to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for subscriptions with the following statuses:</strong></p> <ul> <li>Active</li> <li>Trialing</li> <li>Past due</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Status is sent via email</li> <li>If customer phone is available: Status is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Status is sent via SMS as a fallback</li> </ul> <p>The status notification includes subscription details such as current status, upcoming payments, and recent changes. If no customer contact information is provided, the system will use the details stored in the subscription record.</p> <p><strong>Email notifications include contextual action links based on subscription status:</strong></p> <ul> <li>For past due subscriptions: A link to reactivate the subscription</li> <li>For active and trialing subscriptions: A link to update the payment method</li> </ul> <p>You can specify the customer&#39;s email or phone number, the preferred communication channel (email or SMS), and the language for the message.</p> 
         * @summary Send Subscription Status
         * @param {string} id The subscription ID
         * @param {SendSubscriptionStatusRequest} [sendSubscriptionStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendStatus: async (id: string, sendSubscriptionStatusRequest?: SendSubscriptionStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendStatus', 'id', id)
            const localVarPath = `/subscriptions/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendSubscriptionStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Updates the configuration of an existing subscription.</p> <p><strong>Modifiable Parameters</strong>:</p> <ul> <li>Billing information (amount, description)</li> <li>Customer details (contact information, billing/shipping addresses)</li> <li>Subscription settings (cancelAtPeriodEnd, pauseAtPeriodEnd)</li> <li>Metadata (for your internal tracking)</li> </ul> <p><strong>Update Effects</strong>:</p> <ul> <li>Amount changes apply to the next billing cycle</li> <li>Customer information updates take effect immediately</li> <li>Setting <code>cancelAtPeriodEnd</code> to true will end the subscription after the current period</li> <li>Setting <code>pauseAtPeriodEnd</code> to true will pause billing after the current period</li> </ul> <p><strong>Note</strong>: Some fundamental properties cannot be changed once a subscription is created, including currency and billing interval. To modify these, you would need to cancel the existing subscription and create a new one.</p> 
         * @summary Update Subscription
         * @param {string} id The subscription ID
         * @param {UpdateSubscriptionRequest} updateSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'updateSubscriptionRequest' is not null or undefined
            assertParamExists('update', 'updateSubscriptionRequest', updateSubscriptionRequest)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Activates a subscription by attaching a payment method and initiating the billing cycle.</p> <p><strong>Activation Process</strong>:</p> <ol> <li>This endpoint transitions a <code>PENDING</code> subscription to <code>ACTIVE</code> status</li> <li>An initial payment is created to validate the payment method:<ul> <li>For regular subscriptions: First billing cycle payment is processed immediately</li> <li>For trial subscriptions: A zero-amount payment is created to verify the payment method</li> </ul> </li> </ol> <p><strong>Payment Method Updates</strong>: If the subscription is already active, this endpoint can be used to update the payment method. The update process creates a zero-amount payment to verify the new payment method works correctly.</p> <p><strong>Important Notes</strong>:</p> <ul> <li>Subscription billing begins immediately upon successful activation (unless in trial period)</li> <li>The payment method provided will be used for all future recurring charges</li> <li>Activation failures (due to invalid payment method) will keep the subscription in <code>PENDING</code> status</li> </ul> 
         * @summary Activate Subscription
         * @param {string} id The subscription ID
         * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activate(id: string, activateSubscriptionRequest?: ActivateSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activate(id, activateSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.activate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Cancels an active subscription, permanently stopping the billing cycle.</p> <p><strong>Cancellation Effects</strong>:</p> <ul> <li>The subscription status changes to <code>CANCELED</code></li> <li>No further charges will be processed</li> <li>Access to subscription services typically ends immediately or at period end (depending on your business rules)</li> </ul> <p><strong>Important Notes</strong>:</p> <ul> <li>Cancellation is permanent and cannot be undone</li> <li>To restart service, a new subscription must be created</li> <li>Consider using <code>pauseAtPeriodEnd</code> or <code>cancelAtPeriodEnd</code> for softer transitions</li> </ul> <p>Use this endpoint when a customer wishes to completely terminate their subscription.</p> 
         * @summary Cancel Subscription
         * @param {string} id The subscription ID
         * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, cancelSubscriptionRequest?: CancelSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, cancelSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Creates a new subscription with the specified parameters.</p> <p><strong>Subscription Lifecycle</strong>:</p> <ol> <li>When first created, the subscription has a <code>PENDING</code> status</li> <li>To initiate billing, you must call the <a href=\"#operation/subscriptions_activate\">activate endpoint</a> with payment details</li> <li>Once activated, the subscription will automatically bill according to the configured interval</li> </ol> <p><strong>Key Configuration Parameters</strong>:</p> <ul> <li><strong>Billing settings</strong>: Amount, currency, interval (daily, weekly, monthly, yearly)</li> <li><strong>Schedule customization</strong>: Interval count, trial period duration</li> <li><strong>Customer information</strong>: Contact details, billing and shipping addresses</li> <li><strong>Communication</strong>: Callback URLs for webhook notifications about subscription events</li> </ul> <p><strong>Best Practices</strong>:</p> <ul> <li>Set clear, descriptive names for subscriptions to help with identification</li> <li>Configure appropriate webhook notifications to monitor subscription status changes</li> <li>Consider offering trial periods to increase customer conversion rates</li> <li>Use metadata to store additional information relevant to your business logic</li> </ul> 
         * @summary Create Subscription
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createSubscriptionRequest: CreateSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Retrieves the complete details of an existing subscription by its unique ID.</p> <p>This endpoint returns comprehensive information about the subscription, including:</p> <ul> <li>Current status and lifecycle details (active, paused, canceled)</li> <li>Billing configuration (amount, currency, interval)</li> <li>Schedule information (current period, next payment date)</li> <li>Customer and payment method details</li> <li>Payment history (including last payment status)</li> <li>Trial period information (if applicable)</li> </ul> <p>Use this endpoint to check subscription status, verify billing details, or retrieve information needed for customer support inquiries.</p> 
         * @summary Get Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Pauses an active subscription, temporarily halting the billing cycle.</p> <p><strong>Pause Effects</strong>:</p> <ul> <li>Billing is immediately suspended</li> <li>The subscription status changes to <code>PAUSED</code></li> <li>No charges will be processed while the subscription remains paused</li> <li>The current billing period end date remains unchanged</li> </ul> <p><strong>Use Cases</strong>:</p> <ul> <li>Temporary service interruptions</li> <li>Customer vacation or absence periods</li> <li>Account maintenance or dispute resolution</li> </ul> <p>To resume billing, use the <a href=\"#operation/subscriptions_resume\">resume endpoint</a>.</p> 
         * @summary Pause Subscription
         * @param {string} id The subscription ID
         * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pause(id: string, pauseSubscriptionRequest?: PauseSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pause(id, pauseSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.pause']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Resumes a previously paused subscription, reactivating the billing cycle.</p> <p><strong>Resume Effects</strong>:</p> <ul> <li>Billing is immediately reactivated</li> <li>The subscription status changes from <code>PAUSED</code> to <code>ACTIVE</code></li> <li>The next billing date is recalculated based on the current date</li> <li>Regular charging schedule resumes according to the subscription interval</li> </ul> <p><strong>Important Notes</strong>:</p> <ul> <li>No immediate charge is created when resuming (billing continues on next scheduled date)</li> <li>Any pause duration is added to the current billing period, maintaining the expected number of billing cycles</li> <li>If a significant time has passed, verify that the payment method is still valid</li> </ul> 
         * @summary Resume Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resume(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resume(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.resume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Sends a subscription activation link to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for subscriptions with the following status:</strong></p> <ul> <li>Pending</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Link is sent via email</li> <li>If customer phone is available: Link is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Link is sent via SMS as a fallback</li> </ul> <p>The subscription activation link allows customers to complete their subscription setup by providing payment details on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the subscription record.</p> 
         * @summary Send Subscription Link
         * @param {string} id The subscription ID
         * @param {SendSubscriptionLinkRequest} [sendSubscriptionLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLink(id: string, sendSubscriptionLinkRequest?: SendSubscriptionLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLink(id, sendSubscriptionLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.sendLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Sends subscription status information to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for subscriptions with the following statuses:</strong></p> <ul> <li>Active</li> <li>Trialing</li> <li>Past due</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Status is sent via email</li> <li>If customer phone is available: Status is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Status is sent via SMS as a fallback</li> </ul> <p>The status notification includes subscription details such as current status, upcoming payments, and recent changes. If no customer contact information is provided, the system will use the details stored in the subscription record.</p> <p><strong>Email notifications include contextual action links based on subscription status:</strong></p> <ul> <li>For past due subscriptions: A link to reactivate the subscription</li> <li>For active and trialing subscriptions: A link to update the payment method</li> </ul> <p>You can specify the customer&#39;s email or phone number, the preferred communication channel (email or SMS), and the language for the message.</p> 
         * @summary Send Subscription Status
         * @param {string} id The subscription ID
         * @param {SendSubscriptionStatusRequest} [sendSubscriptionStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendStatus(id: string, sendSubscriptionStatusRequest?: SendSubscriptionStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendStatus(id, sendSubscriptionStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.sendStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Updates the configuration of an existing subscription.</p> <p><strong>Modifiable Parameters</strong>:</p> <ul> <li>Billing information (amount, description)</li> <li>Customer details (contact information, billing/shipping addresses)</li> <li>Subscription settings (cancelAtPeriodEnd, pauseAtPeriodEnd)</li> <li>Metadata (for your internal tracking)</li> </ul> <p><strong>Update Effects</strong>:</p> <ul> <li>Amount changes apply to the next billing cycle</li> <li>Customer information updates take effect immediately</li> <li>Setting <code>cancelAtPeriodEnd</code> to true will end the subscription after the current period</li> <li>Setting <code>pauseAtPeriodEnd</code> to true will pause billing after the current period</li> </ul> <p><strong>Note</strong>: Some fundamental properties cannot be changed once a subscription is created, including currency and billing interval. To modify these, you would need to cancel the existing subscription and create a new one.</p> 
         * @summary Update Subscription
         * @param {string} id The subscription ID
         * @param {UpdateSubscriptionRequest} updateSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, updateSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * <p>Activates a subscription by attaching a payment method and initiating the billing cycle.</p> <p><strong>Activation Process</strong>:</p> <ol> <li>This endpoint transitions a <code>PENDING</code> subscription to <code>ACTIVE</code> status</li> <li>An initial payment is created to validate the payment method:<ul> <li>For regular subscriptions: First billing cycle payment is processed immediately</li> <li>For trial subscriptions: A zero-amount payment is created to verify the payment method</li> </ul> </li> </ol> <p><strong>Payment Method Updates</strong>: If the subscription is already active, this endpoint can be used to update the payment method. The update process creates a zero-amount payment to verify the new payment method works correctly.</p> <p><strong>Important Notes</strong>:</p> <ul> <li>Subscription billing begins immediately upon successful activation (unless in trial period)</li> <li>The payment method provided will be used for all future recurring charges</li> <li>Activation failures (due to invalid payment method) will keep the subscription in <code>PENDING</code> status</li> </ul> 
         * @summary Activate Subscription
         * @param {string} id The subscription ID
         * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate(id: string, activateSubscriptionRequest?: ActivateSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.activate(id, activateSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Cancels an active subscription, permanently stopping the billing cycle.</p> <p><strong>Cancellation Effects</strong>:</p> <ul> <li>The subscription status changes to <code>CANCELED</code></li> <li>No further charges will be processed</li> <li>Access to subscription services typically ends immediately or at period end (depending on your business rules)</li> </ul> <p><strong>Important Notes</strong>:</p> <ul> <li>Cancellation is permanent and cannot be undone</li> <li>To restart service, a new subscription must be created</li> <li>Consider using <code>pauseAtPeriodEnd</code> or <code>cancelAtPeriodEnd</code> for softer transitions</li> </ul> <p>Use this endpoint when a customer wishes to completely terminate their subscription.</p> 
         * @summary Cancel Subscription
         * @param {string} id The subscription ID
         * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, cancelSubscriptionRequest?: CancelSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.cancel(id, cancelSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Creates a new subscription with the specified parameters.</p> <p><strong>Subscription Lifecycle</strong>:</p> <ol> <li>When first created, the subscription has a <code>PENDING</code> status</li> <li>To initiate billing, you must call the <a href=\"#operation/subscriptions_activate\">activate endpoint</a> with payment details</li> <li>Once activated, the subscription will automatically bill according to the configured interval</li> </ol> <p><strong>Key Configuration Parameters</strong>:</p> <ul> <li><strong>Billing settings</strong>: Amount, currency, interval (daily, weekly, monthly, yearly)</li> <li><strong>Schedule customization</strong>: Interval count, trial period duration</li> <li><strong>Customer information</strong>: Contact details, billing and shipping addresses</li> <li><strong>Communication</strong>: Callback URLs for webhook notifications about subscription events</li> </ul> <p><strong>Best Practices</strong>:</p> <ul> <li>Set clear, descriptive names for subscriptions to help with identification</li> <li>Configure appropriate webhook notifications to monitor subscription status changes</li> <li>Consider offering trial periods to increase customer conversion rates</li> <li>Use metadata to store additional information relevant to your business logic</li> </ul> 
         * @summary Create Subscription
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createSubscriptionRequest: CreateSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.create(createSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Retrieves the complete details of an existing subscription by its unique ID.</p> <p>This endpoint returns comprehensive information about the subscription, including:</p> <ul> <li>Current status and lifecycle details (active, paused, canceled)</li> <li>Billing configuration (amount, currency, interval)</li> <li>Schedule information (current period, next payment date)</li> <li>Customer and payment method details</li> <li>Payment history (including last payment status)</li> <li>Trial period information (if applicable)</li> </ul> <p>Use this endpoint to check subscription status, verify billing details, or retrieve information needed for customer support inquiries.</p> 
         * @summary Get Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.get(id, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Pauses an active subscription, temporarily halting the billing cycle.</p> <p><strong>Pause Effects</strong>:</p> <ul> <li>Billing is immediately suspended</li> <li>The subscription status changes to <code>PAUSED</code></li> <li>No charges will be processed while the subscription remains paused</li> <li>The current billing period end date remains unchanged</li> </ul> <p><strong>Use Cases</strong>:</p> <ul> <li>Temporary service interruptions</li> <li>Customer vacation or absence periods</li> <li>Account maintenance or dispute resolution</li> </ul> <p>To resume billing, use the <a href=\"#operation/subscriptions_resume\">resume endpoint</a>.</p> 
         * @summary Pause Subscription
         * @param {string} id The subscription ID
         * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(id: string, pauseSubscriptionRequest?: PauseSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.pause(id, pauseSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Resumes a previously paused subscription, reactivating the billing cycle.</p> <p><strong>Resume Effects</strong>:</p> <ul> <li>Billing is immediately reactivated</li> <li>The subscription status changes from <code>PAUSED</code> to <code>ACTIVE</code></li> <li>The next billing date is recalculated based on the current date</li> <li>Regular charging schedule resumes according to the subscription interval</li> </ul> <p><strong>Important Notes</strong>:</p> <ul> <li>No immediate charge is created when resuming (billing continues on next scheduled date)</li> <li>Any pause duration is added to the current billing period, maintaining the expected number of billing cycles</li> <li>If a significant time has passed, verify that the payment method is still valid</li> </ul> 
         * @summary Resume Subscription
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.resume(id, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Sends a subscription activation link to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for subscriptions with the following status:</strong></p> <ul> <li>Pending</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Link is sent via email</li> <li>If customer phone is available: Link is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Link is sent via SMS as a fallback</li> </ul> <p>The subscription activation link allows customers to complete their subscription setup by providing payment details on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the subscription record.</p> 
         * @summary Send Subscription Link
         * @param {string} id The subscription ID
         * @param {SendSubscriptionLinkRequest} [sendSubscriptionLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLink(id: string, sendSubscriptionLinkRequest?: SendSubscriptionLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.sendLink(id, sendSubscriptionLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Sends subscription status information to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for subscriptions with the following statuses:</strong></p> <ul> <li>Active</li> <li>Trialing</li> <li>Past due</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Status is sent via email</li> <li>If customer phone is available: Status is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Status is sent via SMS as a fallback</li> </ul> <p>The status notification includes subscription details such as current status, upcoming payments, and recent changes. If no customer contact information is provided, the system will use the details stored in the subscription record.</p> <p><strong>Email notifications include contextual action links based on subscription status:</strong></p> <ul> <li>For past due subscriptions: A link to reactivate the subscription</li> <li>For active and trialing subscriptions: A link to update the payment method</li> </ul> <p>You can specify the customer&#39;s email or phone number, the preferred communication channel (email or SMS), and the language for the message.</p> 
         * @summary Send Subscription Status
         * @param {string} id The subscription ID
         * @param {SendSubscriptionStatusRequest} [sendSubscriptionStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendStatus(id: string, sendSubscriptionStatusRequest?: SendSubscriptionStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.sendStatus(id, sendSubscriptionStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Updates the configuration of an existing subscription.</p> <p><strong>Modifiable Parameters</strong>:</p> <ul> <li>Billing information (amount, description)</li> <li>Customer details (contact information, billing/shipping addresses)</li> <li>Subscription settings (cancelAtPeriodEnd, pauseAtPeriodEnd)</li> <li>Metadata (for your internal tracking)</li> </ul> <p><strong>Update Effects</strong>:</p> <ul> <li>Amount changes apply to the next billing cycle</li> <li>Customer information updates take effect immediately</li> <li>Setting <code>cancelAtPeriodEnd</code> to true will end the subscription after the current period</li> <li>Setting <code>pauseAtPeriodEnd</code> to true will pause billing after the current period</li> </ul> <p><strong>Note</strong>: Some fundamental properties cannot be changed once a subscription is created, including currency and billing interval. To modify these, you would need to cancel the existing subscription and create a new one.</p> 
         * @summary Update Subscription
         * @param {string} id The subscription ID
         * @param {UpdateSubscriptionRequest} updateSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.update(id, updateSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * <p>Activates a subscription by attaching a payment method and initiating the billing cycle.</p> <p><strong>Activation Process</strong>:</p> <ol> <li>This endpoint transitions a <code>PENDING</code> subscription to <code>ACTIVE</code> status</li> <li>An initial payment is created to validate the payment method:<ul> <li>For regular subscriptions: First billing cycle payment is processed immediately</li> <li>For trial subscriptions: A zero-amount payment is created to verify the payment method</li> </ul> </li> </ol> <p><strong>Payment Method Updates</strong>: If the subscription is already active, this endpoint can be used to update the payment method. The update process creates a zero-amount payment to verify the new payment method works correctly.</p> <p><strong>Important Notes</strong>:</p> <ul> <li>Subscription billing begins immediately upon successful activation (unless in trial period)</li> <li>The payment method provided will be used for all future recurring charges</li> <li>Activation failures (due to invalid payment method) will keep the subscription in <code>PENDING</code> status</li> </ul> 
     * @summary Activate Subscription
     * @param {string} id The subscription ID
     * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public activate(id: string, activateSubscriptionRequest?: ActivateSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).activate(id, activateSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Cancels an active subscription, permanently stopping the billing cycle.</p> <p><strong>Cancellation Effects</strong>:</p> <ul> <li>The subscription status changes to <code>CANCELED</code></li> <li>No further charges will be processed</li> <li>Access to subscription services typically ends immediately or at period end (depending on your business rules)</li> </ul> <p><strong>Important Notes</strong>:</p> <ul> <li>Cancellation is permanent and cannot be undone</li> <li>To restart service, a new subscription must be created</li> <li>Consider using <code>pauseAtPeriodEnd</code> or <code>cancelAtPeriodEnd</code> for softer transitions</li> </ul> <p>Use this endpoint when a customer wishes to completely terminate their subscription.</p> 
     * @summary Cancel Subscription
     * @param {string} id The subscription ID
     * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public cancel(id: string, cancelSubscriptionRequest?: CancelSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).cancel(id, cancelSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Creates a new subscription with the specified parameters.</p> <p><strong>Subscription Lifecycle</strong>:</p> <ol> <li>When first created, the subscription has a <code>PENDING</code> status</li> <li>To initiate billing, you must call the <a href=\"#operation/subscriptions_activate\">activate endpoint</a> with payment details</li> <li>Once activated, the subscription will automatically bill according to the configured interval</li> </ol> <p><strong>Key Configuration Parameters</strong>:</p> <ul> <li><strong>Billing settings</strong>: Amount, currency, interval (daily, weekly, monthly, yearly)</li> <li><strong>Schedule customization</strong>: Interval count, trial period duration</li> <li><strong>Customer information</strong>: Contact details, billing and shipping addresses</li> <li><strong>Communication</strong>: Callback URLs for webhook notifications about subscription events</li> </ul> <p><strong>Best Practices</strong>:</p> <ul> <li>Set clear, descriptive names for subscriptions to help with identification</li> <li>Configure appropriate webhook notifications to monitor subscription status changes</li> <li>Consider offering trial periods to increase customer conversion rates</li> <li>Use metadata to store additional information relevant to your business logic</li> </ul> 
     * @summary Create Subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public create(createSubscriptionRequest: CreateSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).create(createSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Retrieves the complete details of an existing subscription by its unique ID.</p> <p>This endpoint returns comprehensive information about the subscription, including:</p> <ul> <li>Current status and lifecycle details (active, paused, canceled)</li> <li>Billing configuration (amount, currency, interval)</li> <li>Schedule information (current period, next payment date)</li> <li>Customer and payment method details</li> <li>Payment history (including last payment status)</li> <li>Trial period information (if applicable)</li> </ul> <p>Use this endpoint to check subscription status, verify billing details, or retrieve information needed for customer support inquiries.</p> 
     * @summary Get Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public get(id: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).get(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Pauses an active subscription, temporarily halting the billing cycle.</p> <p><strong>Pause Effects</strong>:</p> <ul> <li>Billing is immediately suspended</li> <li>The subscription status changes to <code>PAUSED</code></li> <li>No charges will be processed while the subscription remains paused</li> <li>The current billing period end date remains unchanged</li> </ul> <p><strong>Use Cases</strong>:</p> <ul> <li>Temporary service interruptions</li> <li>Customer vacation or absence periods</li> <li>Account maintenance or dispute resolution</li> </ul> <p>To resume billing, use the <a href=\"#operation/subscriptions_resume\">resume endpoint</a>.</p> 
     * @summary Pause Subscription
     * @param {string} id The subscription ID
     * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public pause(id: string, pauseSubscriptionRequest?: PauseSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).pause(id, pauseSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Resumes a previously paused subscription, reactivating the billing cycle.</p> <p><strong>Resume Effects</strong>:</p> <ul> <li>Billing is immediately reactivated</li> <li>The subscription status changes from <code>PAUSED</code> to <code>ACTIVE</code></li> <li>The next billing date is recalculated based on the current date</li> <li>Regular charging schedule resumes according to the subscription interval</li> </ul> <p><strong>Important Notes</strong>:</p> <ul> <li>No immediate charge is created when resuming (billing continues on next scheduled date)</li> <li>Any pause duration is added to the current billing period, maintaining the expected number of billing cycles</li> <li>If a significant time has passed, verify that the payment method is still valid</li> </ul> 
     * @summary Resume Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public resume(id: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).resume(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Sends a subscription activation link to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for subscriptions with the following status:</strong></p> <ul> <li>Pending</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Link is sent via email</li> <li>If customer phone is available: Link is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Link is sent via SMS as a fallback</li> </ul> <p>The subscription activation link allows customers to complete their subscription setup by providing payment details on the secure MONEI payment page. If no customer contact information is provided, the system will use the details stored in the subscription record.</p> 
     * @summary Send Subscription Link
     * @param {string} id The subscription ID
     * @param {SendSubscriptionLinkRequest} [sendSubscriptionLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public sendLink(id: string, sendSubscriptionLinkRequest?: SendSubscriptionLinkRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).sendLink(id, sendSubscriptionLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Sends subscription status information to the customer through their preferred communication channel.</p> <p><strong>This API can only be used for subscriptions with the following statuses:</strong></p> <ul> <li>Active</li> <li>Trialing</li> <li>Past due</li> </ul> <p><strong>Delivery channels are automatically selected based on available customer information:</strong></p> <ul> <li>If customer email is available: Status is sent via email</li> <li>If customer phone is available: Status is sent via WhatsApp</li> <li>If WhatsApp delivery fails: Status is sent via SMS as a fallback</li> </ul> <p>The status notification includes subscription details such as current status, upcoming payments, and recent changes. If no customer contact information is provided, the system will use the details stored in the subscription record.</p> <p><strong>Email notifications include contextual action links based on subscription status:</strong></p> <ul> <li>For past due subscriptions: A link to reactivate the subscription</li> <li>For active and trialing subscriptions: A link to update the payment method</li> </ul> <p>You can specify the customer&#39;s email or phone number, the preferred communication channel (email or SMS), and the language for the message.</p> 
     * @summary Send Subscription Status
     * @param {string} id The subscription ID
     * @param {SendSubscriptionStatusRequest} [sendSubscriptionStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public sendStatus(id: string, sendSubscriptionStatusRequest?: SendSubscriptionStatusRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).sendStatus(id, sendSubscriptionStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Updates the configuration of an existing subscription.</p> <p><strong>Modifiable Parameters</strong>:</p> <ul> <li>Billing information (amount, description)</li> <li>Customer details (contact information, billing/shipping addresses)</li> <li>Subscription settings (cancelAtPeriodEnd, pauseAtPeriodEnd)</li> <li>Metadata (for your internal tracking)</li> </ul> <p><strong>Update Effects</strong>:</p> <ul> <li>Amount changes apply to the next billing cycle</li> <li>Customer information updates take effect immediately</li> <li>Setting <code>cancelAtPeriodEnd</code> to true will end the subscription after the current period</li> <li>Setting <code>pauseAtPeriodEnd</code> to true will pause billing after the current period</li> </ul> <p><strong>Note</strong>: Some fundamental properties cannot be changed once a subscription is created, including currency and billing interval. To modify these, you would need to cancel the existing subscription and create a new one.</p> 
     * @summary Update Subscription
     * @param {string} id The subscription ID
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public update(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).update(id, updateSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



