// tslint:disable
/**
 * MONEI API v1
 * The MONEI API is organized around [REST](https://en.wikipedia.org/wiki/Representational_State_Transfer). Our API has predictable resource-oriented URLs, accepts JSON-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs. <br/><br/> **Base URL:** https://api.monei.com/v1 <br/><br/> **Client libraries:** <ul>   <li><a target=\"_blank\" href=\"https://github.com/MONEI/monei-php-sdk\">PHP SDK</a></li>   <li><a target=\"_blank\" href=\"https://github.com/MONEI/monei-python-sdk\">Python SDK</a></li>   <li><a target=\"_blank\" href=\"https://github.com/MONEI/monei-node-sdk\">Node.js SDK</a></li> </ul>
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from '../axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof Address
     */
    country?: string;
    /**
     * City, district, suburb, town, or village.
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * Address line 1 (e.g., street, PO Box, or company name).
     * @type {string}
     * @memberof Address
     */
    line1?: string;
    /**
     * Address line 2 (e.g., apartment, suite, unit, or building).
     * @type {string}
     * @memberof Address
     */
    line2?: string;
    /**
     * ZIP or postal code.
     * @type {string}
     * @memberof Address
     */
    zip?: string;
    /**
     * State, county, province, or region.
     * @type {string}
     * @memberof Address
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface CancelPaymentRequest
 */
export interface CancelPaymentRequest {
    /**
     * 
     * @type {PaymentCancellationReason}
     * @memberof CancelPaymentRequest
     */
    cancellationReason?: PaymentCancellationReason;
}
/**
 * 
 * @export
 * @interface CapturePaymentRequest
 */
export interface CapturePaymentRequest {
    /**
     * The amount to capture, which must be less than or equal to the original amount. Any additional amount will be automatically refunded.
     * @type {number}
     * @memberof CapturePaymentRequest
     */
    amount?: number;
}
/**
 * 
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * The card number, as a string without any separators.
     * @type {string}
     * @memberof Card
     */
    number?: string;
    /**
     * Card security code.
     * @type {string}
     * @memberof Card
     */
    cvc?: string;
    /**
     * Two-digit number representing the card’s expiration month.
     * @type {string}
     * @memberof Card
     */
    expMonth?: string;
    /**
     * Two-digit number representing the card’s expiration year.
     * @type {string}
     * @memberof Card
     */
    expYear?: string;
    /**
     * The cardholder\'s name, as stated in the credit card.
     * @type {string}
     * @memberof Card
     */
    cardholderName?: string;
    /**
     * The cardholder\'s email address.
     * @type {string}
     * @memberof Card
     */
    cardholderEmail?: string;
}
/**
 * 
 * @export
 * @interface ConfirmPaymentRequest
 */
export interface ConfirmPaymentRequest {
    /**
     * A payment token generated by monei.js [Components](https://docs.monei.com/docs/monei-js-overview) or a paymentToken [saved after a previous successful payment](https://docs.monei.com/docs/save-payment-method).
     * @type {string}
     * @memberof ConfirmPaymentRequest
     */
    paymentToken: string;
    /**
     * 
     * @type {ConfirmPaymentRequestPaymentMethod}
     * @memberof ConfirmPaymentRequest
     */
    paymentMethod?: ConfirmPaymentRequestPaymentMethod;
    /**
     * If set to true a permanent token that represents a payment method used in the payment will be generated.
     * @type {boolean}
     * @memberof ConfirmPaymentRequest
     */
    generatePaymentToken?: boolean;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof ConfirmPaymentRequest
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof ConfirmPaymentRequest
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof ConfirmPaymentRequest
     */
    shippingDetails?: PaymentShippingDetails;
}
/**
 * Additional information about the payment method used for this payment.
 * @export
 * @interface ConfirmPaymentRequestPaymentMethod
 */
export interface ConfirmPaymentRequestPaymentMethod {
    /**
     * 
     * @type {ConfirmPaymentRequestPaymentMethodCard}
     * @memberof ConfirmPaymentRequestPaymentMethod
     */
    card?: ConfirmPaymentRequestPaymentMethodCard;
}
/**
 * Additional information about the card used for this payment.
 * @export
 * @interface ConfirmPaymentRequestPaymentMethodCard
 */
export interface ConfirmPaymentRequestPaymentMethodCard {
    /**
     * The cardholder\'s name, as stated in the credit card.
     * @type {string}
     * @memberof ConfirmPaymentRequestPaymentMethodCard
     */
    cardholderName?: string;
    /**
     * The cardholder\'s email address.
     * @type {string}
     * @memberof ConfirmPaymentRequestPaymentMethodCard
     */
    cardholderEmail?: string;
}
/**
 * 
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD).
     * @type {number}
     * @memberof CreatePaymentRequest
     */
    amount: number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    currency: string;
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    orderId: string;
    /**
     * The URL to which a payment result should be sent asynchronously.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    callbackUrl: string;
    /**
     * The URL the customer will be directed to after transaction completed (successful or failed - except if `failUrl` is provided).
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    completeUrl: string;
    /**
     * The URL the customer will be directed to after transaction has failed, instead of `completeUrl` (used in hosted payment page). This allows to provide two different URLs for successful and failed payments.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    failUrl?: string;
    /**
     * The URL the customer will be directed to if they decide to cancel payment and return to your website (used in hosted payment page).
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    cancelUrl?: string;
    /**
     * A payment token generated by monei.js [Components](https://docs.monei.com/docs/monei-js-overview) or a paymentToken [saved after a previous successful payment](https://docs.monei.com/docs/save-payment-method). In case of the first one, you will also need to send the `sessionId` used to generate the token in the first place.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    paymentToken?: string;
    /**
     * A unique identifier within your system that adds security to the payment process. You need to pass the same session ID as the one used on the frontend to initialize MONEI Component (if you needed to). This is required if a payment token (not permanent) was already generated in the frontend.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    sessionId?: string;
    /**
     * If set to true a permanent token that represents a payment method used in the payment will be generated.
     * @type {boolean}
     * @memberof CreatePaymentRequest
     */
    generatePaymentToken?: boolean;
    /**
     * 
     * @type {PaymentPaymentMethodInput}
     * @memberof CreatePaymentRequest
     */
    paymentMethod?: PaymentPaymentMethodInput;
    /**
     * 
     * @type {PaymentPaymentMethods}
     * @memberof CreatePaymentRequest
     */
    allowedPaymentMethods?: PaymentPaymentMethods;
    /**
     * 
     * @type {PaymentTransactionType}
     * @memberof CreatePaymentRequest
     */
    transactionType?: PaymentTransactionType;
    /**
     * 
     * @type {PaymentSequence}
     * @memberof CreatePaymentRequest
     */
    sequence?: PaymentSequence;
    /**
     * An arbitrary string attached to the payment. Often useful for displaying to users.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    description?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof CreatePaymentRequest
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof CreatePaymentRequest
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof CreatePaymentRequest
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * 
     * @type {PaymentSessionDetails}
     * @memberof CreatePaymentRequest
     */
    sessionDetails?: PaymentSessionDetails;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * Unique identifier for the payment.
     * @type {string}
     * @memberof Payment
     */
    id?: string;
    /**
     * Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD).
     * @type {number}
     * @memberof Payment
     */
    amount?: number;
    /**
     * Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency.
     * @type {string}
     * @memberof Payment
     */
    currency?: string;
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system.
     * @type {string}
     * @memberof Payment
     */
    orderId?: string;
    /**
     * An arbitrary string attached to the payment. Often useful for displaying to users.
     * @type {string}
     * @memberof Payment
     */
    description?: string;
    /**
     * MONEI Account identifier.
     * @type {string}
     * @memberof Payment
     */
    accountId?: string;
    /**
     * Unique identifier provided by the bank performing transaction.
     * @type {string}
     * @memberof Payment
     */
    authorizationCode?: string;
    /**
     * Has the value `true` if the payment exists in live mode or the value `false` if the payment exists in test mode.
     * @type {boolean}
     * @memberof Payment
     */
    livemode?: boolean;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof Payment
     */
    status?: PaymentStatus;
    /**
     * Payment status code.
     * @type {string}
     * @memberof Payment
     */
    statusCode?: string;
    /**
     * Human readable status message, can be displayed to a user.
     * @type {string}
     * @memberof Payment
     */
    statusMessage?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof Payment
     */
    customer?: PaymentCustomer;
    /**
     * A permanent token represents a payment method used in the payment. Pass `generatePaymentToken: true` when you creating a payment to generate it. You can pass it as `paymentToken` parameter to create other payments with the same payment method. This token does not expire, and should only be used server-side.
     * @type {string}
     * @memberof Payment
     */
    paymentToken?: string;
    /**
     * 
     * @type {PaymentPaymentMethod}
     * @memberof Payment
     */
    paymentMethod?: PaymentPaymentMethod;
    /**
     * 
     * @type {PaymentShop}
     * @memberof Payment
     */
    shop?: PaymentShop;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof Payment
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof Payment
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * Amount in cents refunded (can be less than the amount attribute on the payment if a partial refund was issued).
     * @type {number}
     * @memberof Payment
     */
    refundedAmount?: number;
    /**
     * Amount in cents refunded in the last transaction.
     * @type {number}
     * @memberof Payment
     */
    lastRefundAmount?: number;
    /**
     * 
     * @type {PaymentLastRefundReason}
     * @memberof Payment
     */
    lastRefundReason?: PaymentLastRefundReason;
    /**
     * 
     * @type {PaymentCancellationReason}
     * @memberof Payment
     */
    cancellationReason?: PaymentCancellationReason;
    /**
     * 
     * @type {PaymentSessionDetails}
     * @memberof Payment
     */
    sessionDetails?: PaymentSessionDetails;
    /**
     * 
     * @type {PaymentTraceDetails}
     * @memberof Payment
     */
    traceDetails?: PaymentTraceDetails;
    /**
     * 
     * @type {PaymentNextAction}
     * @memberof Payment
     */
    nextAction?: PaymentNextAction;
    /**
     * Time at which the resource was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Payment
     */
    createdAt?: number;
    /**
     * Time at which the resource updated last time. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof Payment
     */
    updatedAt?: number;
}
/**
 * Billing information associated with the payment method at the time of the transaction.
 * @export
 * @interface PaymentBillingDetails
 */
export interface PaymentBillingDetails {
    /**
     * The customer’s billing full name.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    name?: string;
    /**
     * The customer’s billing email address.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    email?: string;
    /**
     * The customer’s billing phone number.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    phone?: string;
    /**
     * Billing company name.
     * @type {string}
     * @memberof PaymentBillingDetails
     */
    company?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentBillingDetails
     */
    address?: Address;
}
/**
 * The reason for canceling the Payment.
 * @export
 * @enum {string}
 */
export enum PaymentCancellationReason {
    Duplicated = 'duplicated',
    Fraudulent = 'fraudulent',
    RequestedByCustomer = 'requested_by_customer'
}

/**
 * 
 * @export
 * @interface PaymentCustomer
 */
export interface PaymentCustomer {
    /**
     * The customer’s email address.
     * @type {string}
     * @memberof PaymentCustomer
     */
    email?: string;
    /**
     * The customer’s full name or business name.
     * @type {string}
     * @memberof PaymentCustomer
     */
    name?: string;
    /**
     * The customer’s phone number.
     * @type {string}
     * @memberof PaymentCustomer
     */
    phone?: string;
}
/**
 * The reason of the last refund transaction.
 * @export
 * @enum {string}
 */
export enum PaymentLastRefundReason {
    Duplicated = 'duplicated',
    Fraudulent = 'fraudulent',
    RequestedByCustomer = 'requested_by_customer'
}

/**
 * If present, this property tells you what actions you need to take in order for your customer to fulfill a payment using the provided source.
 * @export
 * @interface PaymentNextAction
 */
export interface PaymentNextAction {
    /**
     * - `CONFIRM` - Your customer needs to be redirected to a   [hosted payment page](https://docs.monei.com/docs/use-prebuilt-payment-page)   or confirm payment using   [payment token](https://docs.monei.com/docs/accept-card-payment#3-submitting-the-payment-to-monei-client-side).   The **redirectUrl** will point to the hosted payment page. - `CHALLENGE` - Your customer needs to be redirected to the   3d secure challenge page provided by the bank. The **redirectUrl**   will point to the 3d secure challenge page provided by the bank. - `COMPLETE` - The payment is completed. The **redirectUrl** will be   the **completeUrl** if it was provided when the payment was created.
     * @type {string}
     * @memberof PaymentNextAction
     */
    type?: PaymentNextActionTypeEnum;
    /**
     * If `true` you have to redirect your customer to the **redirectUrl** to continue payment process.
     * @type {boolean}
     * @memberof PaymentNextAction
     */
    mustRedirect?: boolean;
    /**
     * Redirect your customer to this url to continue payment process.
     * @type {string}
     * @memberof PaymentNextAction
     */
    redirectUrl?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentNextActionTypeEnum {
    CONFIRM = 'CONFIRM',
    CHALLENGE = 'CHALLENGE',
    COMPLETE = 'COMPLETE'
}

/**
 * Details about the payment method at the time of the transaction.
 * @export
 * @interface PaymentPaymentMethod
 */
export interface PaymentPaymentMethod {
    /**
     * Payment method type.
     * @type {string}
     * @memberof PaymentPaymentMethod
     */
    method?: PaymentPaymentMethodMethodEnum;
    /**
     * 
     * @type {PaymentPaymentMethodCard}
     * @memberof PaymentPaymentMethod
     */
    card?: PaymentPaymentMethodCard;
    /**
     * 
     * @type {PaymentPaymentMethodBizum}
     * @memberof PaymentPaymentMethod
     */
    bizum?: PaymentPaymentMethodBizum;
    /**
     * 
     * @type {PaymentPaymentMethodPaypal}
     * @memberof PaymentPaymentMethod
     */
    paypal?: PaymentPaymentMethodPaypal;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodMethodEnum {
    Card = 'card',
    Bizum = 'bizum',
    GooglePay = 'googlePay',
    ApplePay = 'applePay',
    ClickToPay = 'clickToPay',
    Paypal = 'paypal',
    Cofidis = 'cofidis'
}

/**
 * Details about the Bizum account used as payment method at the time of the transaction.
 * @export
 * @interface PaymentPaymentMethodBizum
 */
export interface PaymentPaymentMethodBizum {
    /**
     * The phone number used to pay with `bizum`.
     * @type {string}
     * @memberof PaymentPaymentMethodBizum
     */
    phoneNumber?: string;
}
/**
 * Details about the card used as payment method at the time of the transaction.
 * @export
 * @interface PaymentPaymentMethodCard
 */
export interface PaymentPaymentMethodCard {
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    country?: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    brand?: PaymentPaymentMethodCardBrandEnum;
    /**
     * Card type `debit` or `credit`.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    type?: PaymentPaymentMethodCardTypeEnum;
    /**
     * Wether this transaction used 3D Secure authentication.
     * @type {boolean}
     * @memberof PaymentPaymentMethodCard
     */
    threeDSecure?: boolean;
    /**
     * The protocol version of the 3DS challenge.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    threeDSecureVersion?: string;
    /**
     * The last four digits of the card.
     * @type {string}
     * @memberof PaymentPaymentMethodCard
     */
    last4?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodCardBrandEnum {
    Visa = 'visa',
    Mastercard = 'mastercard',
    Diners = 'diners',
    Amex = 'amex',
    Jcb = 'jcb',
    Unionpay = 'unionpay',
    Unknown = 'unknown'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentMethodCardTypeEnum {
    Debit = 'debit',
    Credit = 'credit'
}

/**
 * An information about a payment method used for this payment. We recommend using `paymentToken` instead, as it is more secure way to pass sensitive payment information. Processing credit card information on your server requires [PCI DSS compliance](https://www.investopedia.com/terms/p/pci-compliance.asp).
 * @export
 * @interface PaymentPaymentMethodInput
 */
export interface PaymentPaymentMethodInput {
    /**
     * 
     * @type {Card}
     * @memberof PaymentPaymentMethodInput
     */
    card?: Card;
}
/**
 * Details from Paypal order used as payment method at the time of the transaction.
 * @export
 * @interface PaymentPaymentMethodPaypal
 */
export interface PaymentPaymentMethodPaypal {
    /**
     * The Paypal\'s order ID.
     * @type {string}
     * @memberof PaymentPaymentMethodPaypal
     */
    orderId?: string;
}
/**
 * An array of allowed payment methods (used in hosted payment page). Must be enabled payment methods. Possible values:   - `card`   - `bizum`   - `applePay`   - `googlePay`   - `clickToPay`   - `paypal`   - `cofidis`
 * @export
 * @interface PaymentPaymentMethods
 */
export interface PaymentPaymentMethods extends Array<string> {
}
/**
 * The reason for refunding the Payment.
 * @export
 * @enum {string}
 */
export enum PaymentRefundReason {
    Duplicated = 'duplicated',
    Fraudulent = 'fraudulent',
    RequestedByCustomer = 'requested_by_customer'
}

/**
 * This field needs to be sent in order to mark the beginning of a sequence of payments (recurring/subscriptions, installments, and so). Specific configurations can be set in the inside properties (`recurring`).
 * @export
 * @interface PaymentSequence
 */
export interface PaymentSequence {
    /**
     * 
     * @type {string}
     * @memberof PaymentSequence
     */
    type: PaymentSequenceTypeEnum;
    /**
     * 
     * @type {PaymentSequenceRecurring}
     * @memberof PaymentSequence
     */
    recurring?: PaymentSequenceRecurring;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentSequenceTypeEnum {
    Recurring = 'recurring'
}

/**
 * Specific configurations for recurring payments. Will only be used when `sequence`.`type` is `recurring`.
 * @export
 * @interface PaymentSequenceRecurring
 */
export interface PaymentSequenceRecurring {
    /**
     * Date after which no further recurring payments will be performed. Must be formatted as `YYYYMMDD`.
     * @type {string}
     * @memberof PaymentSequenceRecurring
     */
    expiry?: string;
    /**
     * The minimum number of **days** between the different recurring payments.
     * @type {number}
     * @memberof PaymentSequenceRecurring
     */
    frequency?: number;
}
/**
 * Information related to the browsing session of the user who initiated the payment.
 * @export
 * @interface PaymentSessionDetails
 */
export interface PaymentSessionDetails {
    /**
     * The IP address where the operation originated.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    ip?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    countryCode?: string;
    /**
     * Two-letter language code ([ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1)).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    lang?: string;
    /**
     * Device type, could be `desktop`, `mobile`, `smartTV`, `tablet`.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    deviceType?: string;
    /**
     * Information about the device used for the browser session (e.g., `iPhone`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    deviceModel?: string;
    /**
     * The browser used in this browser session (e.g., `Mobile Safari`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    browser?: string;
    /**
     * The version for the browser session (e.g., `13.1.1`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    browserVersion?: string;
    /**
     * Operation system (e.g., `iOS`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    os?: string;
    /**
     * Operation system version (e.g., `13.5.1`).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    osVersion?: string;
    /**
     * The source component from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    source?: string;
    /**
     * The source component version from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    sourceVersion?: string;
    /**
     * Full user agent string of the browser session.
     * @type {string}
     * @memberof PaymentSessionDetails
     */
    userAgent?: string;
}
/**
 * Shipping information associated with the payment.
 * @export
 * @interface PaymentShippingDetails
 */
export interface PaymentShippingDetails {
    /**
     * The shipping customer’s full name.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    name?: string;
    /**
     * The shipping customer’s email address.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    email?: string;
    /**
     * The shipping customer’s phone number.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    phone?: string;
    /**
     * Name of the company where the shipment is going.
     * @type {string}
     * @memberof PaymentShippingDetails
     */
    company?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentShippingDetails
     */
    address?: Address;
}
/**
 * The information about the shop (used in [hosted payment page](https://docs.monei.com/docs/use-prebuilt-payment-page)).
 * @export
 * @interface PaymentShop
 */
export interface PaymentShop {
    /**
     * The shop name.
     * @type {string}
     * @memberof PaymentShop
     */
    name?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentShop
     */
    country?: string;
}
/**
 * The status of the payment.
 * @export
 * @enum {string}
 */
export enum PaymentStatus {
    SUCCEEDED = 'SUCCEEDED',
    PENDING = 'PENDING',
    FAILED = 'FAILED',
    CANCELED = 'CANCELED',
    REFUNDED = 'REFUNDED',
    PARTIALLYREFUNDED = 'PARTIALLY_REFUNDED',
    AUTHORIZED = 'AUTHORIZED',
    EXPIRED = 'EXPIRED'
}

/**
 * Information related to the browsing session of the user who initiated the payment.
 * @export
 * @interface PaymentTraceDetails
 */
export interface PaymentTraceDetails {
    /**
     * The IP address where the operation originated.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    ip?: string;
    /**
     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    countryCode?: string;
    /**
     * Two-letter language code ([ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1)).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    lang?: string;
    /**
     * Device type, could be `desktop`, `mobile`, `smartTV`, `tablet`.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    deviceType?: string;
    /**
     * Information about the device used for the browser session (e.g., `iPhone`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    deviceModel?: string;
    /**
     * The browser used in this browser session (e.g., `Mobile Safari`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    browser?: string;
    /**
     * The version for the browser session (e.g., `13.1.1`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    browserVersion?: string;
    /**
     * Operation system (e.g., `iOS`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    os?: string;
    /**
     * Operation system version (e.g., `13.5.1`).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    osVersion?: string;
    /**
     * The source component from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    source?: string;
    /**
     * The source component version from where the operation was generated (mostly for our SDK\'s).
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    sourceVersion?: string;
    /**
     * Full user agent string of the browser session.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    userAgent?: string;
    /**
     * The ID of the user that started the operation.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    userId?: string;
    /**
     * The email of the user that started the operation.
     * @type {string}
     * @memberof PaymentTraceDetails
     */
    userEmail?: string;
}
/**
 * Controls when the funds will be captured.   - `SALE` - **Default**. MONEI automatically captures funds     when the customer authorizes the payment.   - `AUTH` - Place a hold on the funds when the customer authorizes     the payment, but don’t capture the funds until later.
 * @export
 * @enum {string}
 */
export enum PaymentTransactionType {
    SALE = 'SALE',
    AUTH = 'AUTH'
}

/**
 * 
 * @export
 * @interface RecurringPaymentRequest
 */
export interface RecurringPaymentRequest {
    /**
     * An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system.
     * @type {string}
     * @memberof RecurringPaymentRequest
     */
    orderId: string;
    /**
     * The amount to collected by this subsequent payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD).
     * @type {number}
     * @memberof RecurringPaymentRequest
     */
    amount?: number;
    /**
     * Same as the `transactionType` parameter from [create payment](https://docs.monei.com/api/#operation/payments_create). If not sent, it will default in the same transaction type used in the initial payment.
     * @type {PaymentTransactionType}
     * @memberof RecurringPaymentRequest
     */
    transactionType?: PaymentTransactionType;
    /**
     * An arbitrary string attached to the payment. Often useful for displaying to users.
     * @type {string}
     * @memberof RecurringPaymentRequest
     */
    description?: string;
    /**
     * 
     * @type {PaymentCustomer}
     * @memberof RecurringPaymentRequest
     */
    customer?: PaymentCustomer;
    /**
     * 
     * @type {PaymentBillingDetails}
     * @memberof RecurringPaymentRequest
     */
    billingDetails?: PaymentBillingDetails;
    /**
     * 
     * @type {PaymentShippingDetails}
     * @memberof RecurringPaymentRequest
     */
    shippingDetails?: PaymentShippingDetails;
    /**
     * The URL to which a payment result should be sent asynchronously.
     * @type {string}
     * @memberof RecurringPaymentRequest
     */
    callbackUrl?: string;
}
/**
 * 
 * @export
 * @interface RefundPaymentRequest
 */
export interface RefundPaymentRequest {
    /**
     * The amount to refund, which must be less than or equal to the original amount.
     * @type {number}
     * @memberof RefundPaymentRequest
     */
    amount?: number;
    /**
     * 
     * @type {PaymentRefundReason}
     * @memberof RefundPaymentRequest
     */
    refundReason?: PaymentRefundReason;
}

/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status. <br/><br/> This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.
         * @summary Cancel Payment
         * @param {string} id The payment ID
         * @param {CancelPaymentRequest} [cancelPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, cancelPaymentRequest?: CancelPaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cancel.');
            }
            const localVarPath = `/payments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof cancelPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cancelPaymentRequest !== undefined ? cancelPaymentRequest : {}) : (cancelPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`. <br/><br/> Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable.
         * @summary Capture Payment
         * @param {string} id The payment ID
         * @param {CapturePaymentRequest} [capturePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capture: async (id: string, capturePaymentRequest?: CapturePaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling capture.');
            }
            const localVarPath = `/payments/{id}/capture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof capturePaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(capturePaymentRequest !== undefined ? capturePaymentRequest : {}) : (capturePaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status. <br/><br/> You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview). <br/><br/> You can provide additional customer information, it will override the information passed in **create payment** request.
         * @summary Confirm Payment
         * @param {string} id The payment ID
         * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm: async (id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling confirm.');
            }
            const localVarPath = `/payments/{id}/confirm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof confirmPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(confirmPaymentRequest !== undefined ? confirmPaymentRequest : {}) : (confirmPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To charge a credit card or other payment method, you create a Payment. <br/><br/> Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page.
         * @summary Create Payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createPaymentRequest: CreatePaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentRequest' is not null or undefined
            if (createPaymentRequest === null || createPaymentRequest === undefined) {
                throw new RequiredError('createPaymentRequest','Required parameter createPaymentRequest was null or undefined when calling create.');
            }
            const localVarPath = `/payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createPaymentRequest !== undefined ? createPaymentRequest : {}) : (createPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request.
         * @summary Get Payment
         * @param {string} id The payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment. <br/><br/> If amount is not specified, it will default to the same amount from the original payment.
         * @summary Recurring Payment
         * @param {string} sequenceId The sequence ID
         * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurring: async (sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceId' is not null or undefined
            if (sequenceId === null || sequenceId === undefined) {
                throw new RequiredError('sequenceId','Required parameter sequenceId was null or undefined when calling recurring.');
            }
            const localVarPath = `/payments/{sequenceId}/recurring`
                .replace(`{${"sequenceId"}}`, encodeURIComponent(String(sequenceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof recurringPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(recurringPaymentRequest !== undefined ? recurringPaymentRequest : {}) : (recurringPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. <br/><br/> You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded. <br/><br/> Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment.
         * @summary Refund Payment
         * @param {string} id The payment ID
         * @param {RefundPaymentRequest} [refundPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refund: async (id: string, refundPaymentRequest?: RefundPaymentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling refund.');
            }
            const localVarPath = `/payments/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof refundPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(refundPaymentRequest !== undefined ? refundPaymentRequest : {}) : (refundPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status. <br/><br/> This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.
         * @summary Cancel Payment
         * @param {string} id The payment ID
         * @param {CancelPaymentRequest} [cancelPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, cancelPaymentRequest?: CancelPaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).cancel(id, cancelPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`. <br/><br/> Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable.
         * @summary Capture Payment
         * @param {string} id The payment ID
         * @param {CapturePaymentRequest} [capturePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capture(id: string, capturePaymentRequest?: CapturePaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).capture(id, capturePaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status. <br/><br/> You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview). <br/><br/> You can provide additional customer information, it will override the information passed in **create payment** request.
         * @summary Confirm Payment
         * @param {string} id The payment ID
         * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirm(id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).confirm(id, confirmPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * To charge a credit card or other payment method, you create a Payment. <br/><br/> Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page.
         * @summary Create Payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createPaymentRequest: CreatePaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).create(createPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request.
         * @summary Get Payment
         * @param {string} id The payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).get(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment. <br/><br/> If amount is not specified, it will default to the same amount from the original payment.
         * @summary Recurring Payment
         * @param {string} sequenceId The sequence ID
         * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recurring(sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).recurring(sequenceId, recurringPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. <br/><br/> You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded. <br/><br/> Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment.
         * @summary Refund Payment
         * @param {string} id The payment ID
         * @param {RefundPaymentRequest} [refundPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refund(id: string, refundPaymentRequest?: RefundPaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).refund(id, refundPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status. <br/><br/> This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.
         * @summary Cancel Payment
         * @param {string} id The payment ID
         * @param {CancelPaymentRequest} [cancelPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, cancelPaymentRequest?: CancelPaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).cancel(id, cancelPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`. <br/><br/> Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable.
         * @summary Capture Payment
         * @param {string} id The payment ID
         * @param {CapturePaymentRequest} [capturePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capture(id: string, capturePaymentRequest?: CapturePaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).capture(id, capturePaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status. <br/><br/> You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview). <br/><br/> You can provide additional customer information, it will override the information passed in **create payment** request.
         * @summary Confirm Payment
         * @param {string} id The payment ID
         * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm(id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).confirm(id, confirmPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To charge a credit card or other payment method, you create a Payment. <br/><br/> Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page.
         * @summary Create Payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createPaymentRequest: CreatePaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).create(createPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request.
         * @summary Get Payment
         * @param {string} id The payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: string, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).get(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment. <br/><br/> If amount is not specified, it will default to the same amount from the original payment.
         * @summary Recurring Payment
         * @param {string} sequenceId The sequence ID
         * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurring(sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).recurring(sequenceId, recurringPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. <br/><br/> You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded. <br/><br/> Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment.
         * @summary Refund Payment
         * @param {string} id The payment ID
         * @param {RefundPaymentRequest} [refundPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refund(id: string, refundPaymentRequest?: RefundPaymentRequest, options?: any): AxiosPromise<Payment> {
            return PaymentsApiFp(configuration).refund(id, refundPaymentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status. <br/><br/> This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.
     * @summary Cancel Payment
     * @param {string} id The payment ID
     * @param {CancelPaymentRequest} [cancelPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public cancel(id: string, cancelPaymentRequest?: CancelPaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).cancel(id, cancelPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`. <br/><br/> Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable.
     * @summary Capture Payment
     * @param {string} id The payment ID
     * @param {CapturePaymentRequest} [capturePaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public capture(id: string, capturePaymentRequest?: CapturePaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).capture(id, capturePaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status. <br/><br/> You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview). <br/><br/> You can provide additional customer information, it will override the information passed in **create payment** request.
     * @summary Confirm Payment
     * @param {string} id The payment ID
     * @param {ConfirmPaymentRequest} [confirmPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public confirm(id: string, confirmPaymentRequest?: ConfirmPaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).confirm(id, confirmPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To charge a credit card or other payment method, you create a Payment. <br/><br/> Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page.
     * @summary Create Payment
     * @param {CreatePaymentRequest} createPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public create(createPaymentRequest: CreatePaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).create(createPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request.
     * @summary Get Payment
     * @param {string} id The payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public get(id: string, options?: any) {
        return PaymentsApiFp(this.configuration).get(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment. <br/><br/> If amount is not specified, it will default to the same amount from the original payment.
     * @summary Recurring Payment
     * @param {string} sequenceId The sequence ID
     * @param {RecurringPaymentRequest} [recurringPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public recurring(sequenceId: string, recurringPaymentRequest?: RecurringPaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).recurring(sequenceId, recurringPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged. <br/><br/> You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded. <br/><br/> Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment.
     * @summary Refund Payment
     * @param {string} id The payment ID
     * @param {RefundPaymentRequest} [refundPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public refund(id: string, refundPaymentRequest?: RefundPaymentRequest, options?: any) {
        return PaymentsApiFp(this.configuration).refund(id, refundPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


